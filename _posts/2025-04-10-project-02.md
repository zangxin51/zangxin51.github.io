---
layout:     post
title:      "秒杀项目练习2"
subtitle:   ""
date:       2025-04-10 08:44:27
author:     "zangxin"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
---

秒杀项目

### 秒杀方案

1. 秒杀/高并发主要解决两个问题, 并发读, 并发写
2. 并发读核心优化理念就是尽量减少读DB, 或者读更少的数据, 并发写也是一样的
3. 针对秒杀系统需要做一些防护, 针对意料做设计兜底, 防止意外发生
4. 系统架构要满足高可用: 流量复合预期,要稳定, 保证秒杀活动顺利完成, 秒杀商品顺利的卖出去,这个是前提
5. 系统保证数据的一致性, 就是秒杀10个商品, 那就只能成交10个商品, 多一个少一个都不行, 一旦库存不对, 就要承担损失.
6. 系统要满足高性能, 也就是系统的性能要足够高,需要支撑大流量, 不光是服务端要做到极致的性能优化, 而且在整个请求链路上都要做协同优化
7. 秒杀涉及大量的并发读和并发写, 因此支持高并发访问非常关键, 对应方案: 页面缓存(静态化), redis预减库存/内存标记与隔离, 请求削峰(rabbitmq异步请求), 分布式session共享

### 设计



### 编码

数据库

```mysql
create database seckill charset utf8mb4 collate utf8mb4_general_ci;
```

#### 1.用户登录+参数校验+全局异常处理

用户表

```mysql
drop table if exists `seckill_user`;
create table seckill_user
(
    id                bigint       not null comment '用户ID, 主键, 手机号',
    nickname          varchar(255) not null default '',
    `password`        varchar(32)  not null default '' comment 'md5(md5(pass明文+固定salt)+salt)',
    `salt`            varchar(10)  not null default '',
    `head`            varchar(128) not null default '' comment '头像',
    `register_date`   datetime              default null comment '注册时间',
    `last_login_date` datetime              default null comment '最后一次登录时间',
    `login_count`     int(11)               default '0' comment '登录次数',
    primary key (id)
) engine = InnoDB charset = utf8mb4;
```

```mysql
-- 测试数据
-- 13312345678/13312345678 salt=12345678
insert into seckill_user(id, nickname, password, salt, head, register_date, last_login_date, login_count)
VALUES ('13312345678', 'zangxin', '77ac31522b6361cb71c69f9ad0c45f76', '12345678', '', current_timestamp(), current_timestamp(), 1);
```



密码加密问题:

方式1 前端明文-->后端md5(明文)-->数据库

方式二 前端md5(明文)-->后端(md5(md5(明文))--->DB

方式三 前端md5(明文+salt1)-->后端(md5(md5(明文+salt1)+salt2)

 每个用户的salt都不一样

需求:用户登录

```java
@Override
    public ResponseBean login(LoginVo loginVo) {
        String mobile = loginVo.getMobile();
        String password = loginVo.getPassword();
        // 判空
        if (!StringUtils.hasText(mobile) || !StringUtils.hasText(password)) {
            return ResponseBean.error(ResponseBeanEnum.LOGIN_ERROR);
        }
        // 手机号码格式
        if (!ValidatorUtil.isMobile(mobile)) {
            return ResponseBean.error(ResponseBeanEnum.MOBILE_ERROR);
        }
        // 查询数据库
        User user = userMapper.selectById(mobile);
        if (null == user) {// user not exist
            return ResponseBean.error(ResponseBeanEnum.MOBILE_NOT_EXIST);
        }
        // 校验密码, LoginVo这里拿到的密码是mid密码, 客户端已经第一次加盐了
        String salt2 = user.getSalt();
        String dbPass = MD5Util.midPassToDBPass(password, salt2);
        if (!dbPass.equals(user.getPassword())) {
            return ResponseBean.error(ResponseBeanEnum.LOGIN_ERROR);
        }
        return ResponseBean.success();
    }
```

```java
@Data
public class LoginVo {
    private String mobile;
    private String password;
}
```



自定义注解来校验参数(手机号/密码)

```java
@Target({METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE})
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = {IsMobileValidator.class})
public @interface IsMobile {
    String message() default "手机号码格式错误";

    Class<?>[] groups() default {};

    Class<? extends Payload>[] payload() default {};

    boolean required() default true;
}
```

```java
public class IsMobileValidator implements ConstraintValidator<IsMobile, String> {
    private boolean required = false;

    @Override
    public void initialize(IsMobile anno) {
        required = anno.required();
    }

    @Override
    public boolean isValid(String value, ConstraintValidatorContext constraintValidatorContext) {
        // 必填手机号
        if (required) {
            return ValidatorUtil.isMobile(value);
        } else {
            if (!StringUtils.hasText(value)) { // 为空时不校验
                return true;
            } else {
                return ValidatorUtil.isMobile(value);
            }
        }
    }
}
```

```java
// 使用注解
@Data
public class LoginVo {
    @IsMobile(message = "你很伟大~")
    @NotNull
    private String mobile;

    @NotNull
    @Length(min = 32)
    private String password;
}
```

```java
@RequestMapping("/doLogin")
@ResponseBody
// 必须加@Validated
public ResponseBean doLogin(@Validated LoginVo loginVo) {
  log.info("登录入参: loginVo={}", loginVo);
  return userService.login(loginVo);
}
```

```java
// 改进后的service
@Override
public ResponseBean login(LoginVo loginVo) {
  String mobile = loginVo.getMobile();
  String password = loginVo.getPassword();
  // 查询数据库
  User user = userMapper.selectById(mobile);
  if (null == user) {// user not exist
    throw new GlobalException(ResponseBeanEnum.MOBILE_NOT_EXIST);
  }
  // 校验密码, LoginVo这里拿到的密码是mid密码, 客户端已经第一次加盐了
  String salt2 = user.getSalt();
  String dbPass = MD5Util.midPassToDBPass(password, salt2);
  if (!dbPass.equals(user.getPassword())) {
    throw new GlobalException(ResponseBeanEnum.LOGIN_ERROR);
  }
  return ResponseBean.success();
}
```

全局异常处理

```java
// 全局异常类
@Data
@AllArgsConstructor
public class GlobalException extends RuntimeException{
    private ResponseBeanEnum responseBeanEnum;

}
```

```java
// 全局异常处理类
@RestControllerAdvice
public class GlobalExceptionHandler {
    // 处理所有的异常
    @ExceptionHandler(Exception.class)
    public ResponseBean ExceptionHandler(Exception e) {
        // 如果是全局异常，正常处理
        if (e instanceof GlobalException) {
            GlobalException ex = (GlobalException) e;
            return ResponseBean.error(ex.getResponseBeanEnum());
        } else if (e instanceof BindException) {
            // 如果是绑定异常 :由于我们自定义的注解只会在控制台打印错误信息，想让该信息传给前端。
            // 需要获取改异常 BindException中注解定义消息，返回给前端
            BindException ex = (BindException) e;
            ResponseBean respBean = ResponseBean.error(ResponseBeanEnum.BING_ERROR);
            // respBean.setMessage("参数校验异异常");
            String defaultMessage = ex.getBindingResult().getAllErrors().get(0).getDefaultMessage();
            respBean.setMessage(defaultMessage);
            return respBean;
        }
        // 兜底异常
        return ResponseBean.error(ResponseBeanEnum.ERROR);
    }
}
```



#### 2.session

用户登录成功后需要保存 session, 保持登录状态, 然后进入到商品页面

给登录成功的用设置一个cookie: userTicket

```java
// 用户登录成功
// 给每一个用户生成一个ticket-唯一的标识一个用户
String ticket = UUIDUtil.uuid();
// 将用户登录信息保存到session中
request.getSession().setAttribute(ticket, user);
// 设置cookie
CookieUtil.setCookie(request, response, "userTicket", ticket);
```

<img src="../img/md-img/2025-03-26-project-01/截屏2025-04-10 15.22.15.png" alt="截屏2025-04-10 15.22.15" style="zoom:50%;" />

```java
// 商品页面会对登录进行校验
@RequestMapping("/toList")
public String toList(HttpSession session, Model model,
                     @CookieValue(value = "userTicket", required = false) String userTicket) {
  User user = (org.xxx.seckill.pojo.User) session.getAttribute(userTicket);
  if (!StringUtils.hasText(userTicket)) {
    return "login";
  }
  if (null == user) { // 用户没有成功登录,或者userTicket不正确
    return "login";
  }
  // 将用户信息放入到model中, 给模板使用
  model.addAttribute("user", user);
  return "goodsList";
}
```

分布式session问题

**1**、当**Nginx** **对请求进行负载均衡后**,**可能对应到不同的** **Tomcat**

**2**、比如第**1** **次请求**,**均衡到** **TomcatA,** **这时** **Session** **就记录在** **TomcatA,** **第** **2** **次请求， 均衡到** **TomcatB,** **这时就出现问题了，因为** **TomcatB** **会认为该用户是第** **1** **次来，就会 允许购买请求**

**3**、这样就会造成重复购买

解决方案

**session**绑定**/**粘滞

<img src="../img/md-img/2025-03-26-project-01/截屏2025-04-10 16.21.58.png" alt="截屏2025-04-10 16.21.58" style="zoom:50%;" />

**概述**: **服务器会把某个用户的请求**交给**tomcat** **集群中的一个节点，以后此节点就负责该保存该用户的** session

**1) Session** **绑定可以利用负载均衡的源地址** **Hash(ip_hash)**算法实现

**2)** **负载均衡服务器总是将来源手同一个** **IP** **的请求分发到同一台服务器上，也可以根**

**据** **Cookie** **信息将同一个用户的请求总是分发到同一台服务器上**

**3)**这样整个会话期间，该用户所有的请求都在同一台服务器上处理，即**Session** **绑定 在某台特定服务器上，保证** **Session** **总能在这台服务器上获取。这种方法又被称为** **session** **黏滞**/**粘滞**

优点: 不占用服务端内存

缺点: 1) 增加新机器，会重新 Hash，导致重新登录 2) 应用重启, 需要重新登录 3) 某台服务器宕机，该机器上 的 Session 也就不存在了，用户请求切换到其他机器后因为没有 Session 而无法完成业务处理， 这种方案不符合 系统高可用需求, 使用较少

Session复制

<img src="../img/md-img/2025-03-26-project-01/截屏2025-04-10 16.25.01.png" alt="截屏2025-04-10 16.25.01" style="zoom:50%;" />

**Session** **复制是小型架构使用较多的一种服务器集群** **Session** **管理机制**

**-** **应用服务器开启** **Web** **容器的** **Session** **复制功能，在集群中的几台服务器之间同步** **Session** **对象，使每台服务器上都保存了所有用户的** **Session** **信息**

**-** **这样任何一台机器宕机都不会导致** **Session** **数据的丢失，而服务器使用** **Session** **时， 也只需要在本机获取即可**

优点: 无需修改代码，修改 Tomcat 配置即可

缺点: session同步战术内网带宽, 多台tomcat同步性能下降,session占用内存

前端存储

优点: 不占用服务端内存

缺点: 1) 存在安全风险 2) 数据大小受 cookie 限制 3) 占用外网带宽

**后端集中存储**

优点:安全，容易水平扩展(session放redis, 读session从redis中读取)

缺点:增加复杂度，需要修改代码

分布式 **Session** 解决方案 **1-SpringSession** 实现分布式 **Session**(**后端集中存储**)

一句话:将用户 **Session** 不再存放到各自登录的 **Tomcat** 服务器**,**而是统一存放到 **Redis**，从而解决 **Session** 分布式问题

需求: 把用户登录成功的session信息保存在指定的redis中

配置redis: 192.168.2.85:6379, 可视化工具: another redis desktop manager

引入spring-session依赖

```xml
<!--redis依赖-->
<!--spring data redis 依赖, 即 spring 整合 redis-->
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency> <!--pool2 对象池依赖-->
<dependency>
  <groupId>org.apache.commons</groupId>
  <artifactId>commons-pool2</artifactId>
</dependency>
<!--实现分布式 session, 即将 Session 保存到指定的 Redis-->
<dependency>
  <groupId>org.springframework.session</groupId>
  <artifactId>spring-session-data-redis</artifactId>
</dependency>
```

配置文件-是的只用配置redis

```properties
# redis
spring.redis.host=192.168.2.85
spring.redis.port=6379
spring.redis.database=0
spring.redis.timeout=10000ms
#最大连接数:默认是 8
spring.redis.lettuce.pool.max-active=20
#最大连接阻塞等待时间，默认是-1
spring.redis.lettuce.pool.max-wait=10000ms
#最大空闲连接，默认是 8
spring.redis.lettuce.pool.max-idle=200
#最小空闲连接，默认是 0
spring.redis.lettuce.pool.min-idle=5
```

登录一下, redis中就有session数据了结果

<img src="../img/md-img/2025-03-26-project-01/截屏2025-04-10 16.58.52.png" alt="截屏2025-04-10 16.58.52" style="zoom:50%;" />

**-** **前面将** **Session** **统一存放指定** **Redis,** **是以原生的形式存放**, **在操作时**, **还需要反序列化， 不方便**

**-** **我们进行改进**: **直接将登录用户信息统一存放到** **Redis,** **利于操作**

具体步骤:

注释掉spring-session-data-redis依赖

自定义redisTemplate实现序列化

```java
@Configuration
public class RedisConfig {
    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) {
        RedisTemplate<String, Object> redisTemplate = new RedisTemplate<>();
        // 设置相应 key 的序列化
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        // value 序列化
        // redis 默认是 jdk 的序列化是二进制,这里使用的是通用的 json 数据,不用传具体的序列化的对象
        redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        // 设置相应的 hash 序列化
        redisTemplate.setHashKeySerializer(new StringRedisSerializer());
        redisTemplate.setHashValueSerializer(new GenericJackson2JsonRedisSerializer()); // 注入连接工厂
        redisTemplate.setConnectionFactory(redisConnectionFactory);
        return redisTemplate;
    }
```



修改登录成功的service代码-存放用户信息到redis中

```java
// 用户登录成功
// 给每一个用户生成一个ticket-唯一的标识一个用户
String ticket = UUIDUtil.uuid();
// 将用户登录信息保存到session中
// request.getSession().setAttribute(ticket, user);
redisTemplate.opsForValue().set("user:" + ticket, user);
CookieUtil.setCookie(request, response, "userTicket", ticket);
return ResponseBean.success();
```

service增加方法,根据cookie获取user

```java
/**
 * 根据cookie从redis中获取用户
 * @param userTicket 登录后给用户分配标志
 * @return user
 */
@Override
public User getUserByCookie(String userTicket,HttpServletRequest request, HttpServletResponse response) {
  if (!StringUtils.hasText(userTicket)) {
    return null;
  }
  User user = (User) redisTemplate.opsForValue().get("user:" + userTicket);
  if (user != null) {
    // 如果user不为null, 刷新cookie的存活时间
    CookieUtil.setCookie(request, response, "userTicket", userTicket);
  }
  return user;
}
```



controller代码修改-登录校验

```java
 User user = userService.getUserByCookie(userTicket, request, response);
```

再次登录(http://127.0.0.1/goods/toList)查看redis



<img src="../img/md-img/2025-03-26-project-01/截屏2025-04-10 17.17.15.png" alt="截屏2025-04-10 17.17.15" style="zoom:50%;" />

实现 WebMvcConfigurer ,优化登录

**1**、获取浏览器传递的 **cookie** 值，进行参数解析，直接转成 **User** 对象，继续传递**.**

节省controller的参数列表: 

```java
@RequestMapping("/toList")
public String toList(HttpSession session, Model model, HttpServletRequest request, HttpServletResponse response,
                     @CookieValue(value = "userTicket", required = false) String userTicket) {}
```

变成

```java
@RequestMapping("/toList")
public String toList(Model model, User user) 
```

实现步骤

定义参数解析器

```java
@Component
public class UserArgumentResolver implements HandlerMethodArgumentResolver {
    @Autowired
    private UserService userService;

    //如果这个方法返回 true 才会执行下面的 resolveArgument 方法
    // 返回 false 不执行下面的方法
    @Override
    public boolean supportsParameter(MethodParameter parameter) {
        Class<?> parameterType = parameter.getParameterType();
        return User.class == parameterType;
    }

    // * 这个方法，类似拦截器，将传入的参数，取出 cookie 值，然后获取对应的 User 对象
    // * 并把这个 User 对象作为参数继续传递.
    @Override
    public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {
        HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);
        HttpServletResponse response = webRequest.getNativeResponse(HttpServletResponse.class);
        String userTicket = CookieUtil.getCookieValue(request, "userTicket");
        if (!StringUtils.hasText(userTicket)) {
            return null;
        }
        //根据 cookie-ticket 到 Redis 获取 User
        User user = userService.getUserByCookie(userTicket, request, response);
        return user;
    }
}
```

注册解析器

```java
@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {
    @Autowired
    private UserArgumentResolver userArgumentResolver;
    // 自定义参数解析
    @Override
    public void addArgumentResolvers(List<HandlerMethodArgumentResolver> resolvers) {
        resolvers.add(userArgumentResolver);
    }
}
```

修改controller 方法入参

```java
@RequestMapping("/toList")
public String toList(Model model, User user) {
    if (null == user) { // 用户没有成功登录,或者userTicket不正确
        return "login";
    }
    // 将用户信息放入到model中, 给模板使用
    model.addAttribute("user", user);
    return "goodsList";
}
```

秒杀商品列表

登录成功后, 进入商品列表页面: http://127.0.0.1/goods/toList, goodsList.html

商品表

```mysql
-- 商品表
DROP TABLE IF EXISTS `t_goods`;
CREATE TABLE `t_goods`
(
    `id`           BIGINT(20)  NOT NULL AUTO_INCREMENT COMMENT '商品 id',
    `goods_name`   VARCHAR(16) not null DEFAULT '',
    `goods_title`  VARCHAR(64) not null DEFAULT '' COMMENT '商品标题',
    `goods_img`    VARCHAR(64) not null DEFAULT '' COMMENT '商品图片',
    `goods_detail` LONGTEXT    not null COMMENT '商品详情',
    `goods_price`  DECIMAL(10, 2)       DEFAULT '0.00' COMMENT '商品价格',
    `goods_stock`  INT(11)              DEFAULT '0' COMMENT '商品库存',
    PRIMARY KEY (`id`)
) ENGINE = INNODB
  AUTO_INCREMENT = 3
  DEFAULT CHARSET = utf8mb4;
-- 测试数据
INSERT INTO `t_goods` VALUES ('1', '整体厨房设计-套件', '整体厨房设计-套件', '/imgs/kitchen.jpg', '整体厨房设计-套件', '15266.00', '100');
INSERT INTO `t_goods` VALUES ('2', '学习书桌-套件', '学习书桌-套件', '/imgs/desk.jpg', '学习书桌-套件', '5690.00', '100');

```



秒杀商品表

```mysql
--  秒杀商品表
DROP TABLE IF EXISTS `t_seckill_goods`;
CREATE TABLE `t_seckill_goods`
(
    `id`            BIGINT(20) NOT NULL AUTO_INCREMENT,
    `goods_id`      BIGINT(20)     DEFAULT 0,
    `seckill_price` DECIMAL(10, 2) DEFAULT '0.00',
    `stock_count`   INT(10)        DEFAULT 0,
    `start_date`    DATETIME       DEFAULT NULL,
    `end_date`      DATETIME       DEFAULT NULL,
    PRIMARY KEY (`id`)

) ENGINE = INNODB
  AUTO_INCREMENT = 3
  DEFAULT CHARSET = utf8mb4;
INSERT INTO `t_seckill_goods` VALUES ('1', '1', '5266.00', '0', '2022-11-18 19:36:00', '2022-11-19 09:00:00');
INSERT INTO `t_seckill_goods` VALUES ('2', '2', '690.00', '10', '2022-11-18 08:00:00', '2022-11-19 09:00:00');

```

生成对应的mapper, pojo,mapper.xml文件

显示商品列表的实体类GoodsVo

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class GoodsVo extends Goods {
    private BigDecimal seckillPrice;
    private Integer stockCount;
    private Date startDate;
    private Date endDate;
}
```



