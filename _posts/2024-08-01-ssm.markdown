---
layout:     post
title:      "SSM框架"
subtitle:   "ssm"
date:       2024-08-01 11:58:00
author:     "zangxin"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
---

**SSM**

## 1.spring

用途: 简化javaweb开发

- [ ] **IOC**
- [ ] **AOP**(事务)

官网: spring.io

Spring Framework

Spring Boot

### 1.1spring 架构

![image-20240801091412451](\img\md-img\image-20240801091412451.png)

### 1.2 IOC

**IOC**: inversion of control 控制反转, 使用对象时由自己**new**对象, 转换成, 由**外部**提供对象, 对象创建的控制权限转移到**外部**.

**IOC**容器: spring提供了一个容器, 就是上面的**外部**. IOC容器负责对象的创建, 初始化的工作, 被创建的对象在IOC容器中称为Bean.

**DI**: dependency injection 依赖注入,

- 在容器中建立bean与bean之间的依赖关系, 自动注入bean

**解耦**

- 使用IOC容器管理bean (IOC)
- 在IOC容器中将有依赖关系的bean进行绑定(DI)
- 效果: 使用对象时可以从IOC容器中获取, 并且bean已经绑定对其他bean的依赖关系
- **不用new对象, 依赖自动处理好**

#### 1.2.1 spring quickstart

1. 管理什么? (service与dao)
2. 如何将管理对象告知IOC容器? (配置)
3. 如何获取IOC容器? (接口)
4. 如何从IOC中获取bean? 
5. 如何使用spring? (pom.xml)

##### 1.配置maven坐标

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>5.3.30</version>
</dependency>
```

##### 2.在resources目录下配置applicationContext.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean class="com.xxx.spring.dao.impl.BookDaoImpl" id="bookDao"/>

    <bean class="com.xxx.spring.servcie.impl.BookServiceImpl" id="bookService"></bean>
    
</beans>
```

##### 3.**从IOC容器获取bean测试**

```java
public class APP {
    public static void main(String[] args) {
        // 获取容器
        ApplicationContext context = new 	ClassPathXmlApplicationContext("classpath:*.xml");
        BookDao bookDao = context.getBean("bookDao", BookDao.class);
        bookDao.addBook();

        BookService bookService = (BookService) context.getBean("bookService");
        bookService.addBook();
    }
}
```

##### 4.DI测试

```java
public class BookServiceImpl implements BookService {
    // 不用new对象了,只用声明有这个属性
    private BookDao bookDao;

    @Override
    public void addBook() {
        bookDao.addBook();
        System.out.println("add success [BookServiceImpl]");

    }
	// 必须添加setter方法
    public void setBookDao(BookDao bookDao) {
        this.bookDao = bookDao;
    }
}
```

绑定service和dao的关系

```xml
<bean class="com.xxx.spring.dao.impl.BookDaoImpl" id="bookDao"/>

<!-- 配置service与dao的关系, 绑他两的关系 -->
<bean class="com.xxx.spring.servcie.impl.BookServiceImpl" id="bookService">
    <property name="bookDao" ref="bookDao"></property>
</bean>
```

#### 1.2.2 bean的配置

bean标签的属性

id和name效果相同, ref=name/id和ctx.get(name/id)

property:设置属性,利用setter方法

scop:  决定ctx.get()出来对象是不是同一个

- singleton 单例
- prototype 非单例
- 适合单例的对象: 表现层对象, 业务层,dao层,工具类, 不适合的: 请求对象/属性经常变化



#### 1.2.3bean的实例化

##### **1.无参构造方法**

暴力破解反射,私有构造器也可以造对象 ,但是必须提供无参构造器, 否则会异常:

No default constructor found; nested exception is java.lang.NoSuchMethodException: com.xxx.spring.dao.impl.BookDaoImpl.\<init>()

```java
try {
    BookDao obj = (BookDao) clazz.newInstance();
    obj.addBook();
} catch (Exception e) {}
```

##### 2.静态工厂

```xml
<!--  使用静态工厂实例化bean,class写工厂类  -->
<bean class="com.xxx.spring.factory.BookDaoFactory" id="bookDao" factory-method="getBookDao"/>
```

```java
// 静态工厂
public class BookDaoFactory {
    public static BookDao getBookDao() {
        return new BookDaoImpl();
    }
}
```

##### 3.实例工厂

```xml
<!--  实例工厂  -->
<bean id="instanceFactory" class="com.xxx.spring.factory.BookDaoInstanceFactory"/>
<bean id="bookDao" factory-method="getBookDao" factory-bean="instanceFactory"/>
```

```java
// 实例工厂
public class BookDaoInstanceFactory {
    public  BookDao getBookDao() {
        return new BookDaoImpl();
    }
}
```

4. FactoryBean 实例工厂的简化(配置两个bean简化一个bean)  实现FactoryBean接口

```xml
    <!-- FactoryBean方式 -->
    <bean id="bookDao" class="com.xxx.spring.factory.BookDaoFactoryBean"/>	
```

```java
public class BookDaoFactoryBean implements FactoryBean<BookDao> {
    // 代替原始实例工厂中创建对象的方法
    public BookDao getObject() throws Exception {
        return new BookDaoImpl();
    }

    public Class<?> getObjectType() {
        return BookDao.class;
    }
}
```

1.2.4bean的生命周期

- 初始化容器
  1. 创建对象
  2. 执行构造方法
  3. 执行属性注入(setter)
  4. 执行bean初始化方法 (init-method  InitializingBean接口的afterPropertiesSet方法)
- 使用bean
  1. 执行业务操作
- 关闭/销毁容器
  1. 执行bean销毁方法 (DisposableBean.destroy()方法)

bean的销毁方式两种 (ApplicationContext的子接口ConfigurableApplicationContext下面两个方法)

ctx.close()

// 注册关闭钩子

ctx.registerShutdownHook()

### 1.3 DI 依赖注入

#### 1.setter和构造器注入

- 依赖注入的方式

  1. 普通方法
  2. 构造方法

- 注入的类型

  1. 引用类型
  2. 简单类型(含String)

- **依赖注入方式 (2*2 四种)**

  - 1.setter注入(**用property标签** **setter方法必须**)

    - **简单类型 (value)**

      ```xml
      <property name="databaseUrl" value="jdbc:mysql://localhost:3306/top_news"></property>
      ```

      

    - **引用类型(ref)**

      ```xml
      <property name="bookDao" ref="bookDao"></property>
      ```

  - 构造器注入(必须有全部参数构造器, 可以没有空参构造器)

    - 简单类型(**用constructor-arg标签**)

    - 引用类型


```xml
<!--  形参名要和构造器一致,形参耦合问题  -->
<bean id="userService" class="com.xxx.spring.servcie.impl.UserServiceImpl">
  <constructor-arg name="username" value="root"></constructor-arg>
  <constructor-arg name="userDao" ref="userDao"></constructor-arg>
</bean>

<!--  按类型注入 不靠谱的解决方法 -->
<bean id="userService" class="com.xxx.spring.servcie.impl.UserServiceImpl">
  <constructor-arg type="com.xxx.spring.dao.UserDao" ref="userDao"></constructor-arg>
  <constructor-arg type="java.lang.String" value="root"></constructor-arg>
</bean>

<!--  按参数位置 费力的解决方法 -->
<bean id="userService" class="com.xxx.spring.servcie.impl.UserServiceImpl">
  <constructor-arg index="0" ref="userDao"></constructor-arg>
  <constructor-arg index="1" value="root"></constructor-arg>
</bean>

<bean id="userDao" class="com.xxx.spring.dao.impl.UserDaoImpl"/>
```



#### 2.依赖注入方式选择

1. 强制依赖使用构造器进行, 使用setter有概率不进行注入导致null对象出现
2. 可选依赖使用setter注入进行,灵活性强
3. spring倡导使用构造器,第三方框架内部大多数采用构造器注入进行数据初始化,相对严谨
4. 如果有必要可以二者一起用
5. 根据实际情况, 没有setter方法就只能用构造器
6. 自己开发的模块使用setter注入(简单好用)

#### 3.依赖自动装配 autowire

1. 按类型 (autowire="byType") 

   ioc找到的目标类型应只有一个 

   需要setter方法

   ```xml
   <bean class="com.xxx.spring.servcie.impl.BookServiceImpl" id="bookService" autowire="byType">
   ```

2. 按名称装配: (autowire="byName")  名称指的是setter方法的名字

   ```xml
   <!-- 配置service与dao的关系, 绑他两的关系 -->
   <bean class="com.xxx.spring.servcie.impl.BookServiceImpl" id="bookService" autowire="byName">
   ```

自动装配的优先级低于setter注入和构造器注入, 同时出现自动装配失效

优先选择按类型自动装配, 按名称自动装配不推荐使用,使用名称耦合度提高了

#### 4.集合注入

数组, list, set, map, properties

```java
public class BookDaoImpl implements BookDao {
    private int[] array;

    private List<String> list;
    private Set<String> set;

    private Map<String, String> map;
    private Properties properties;

    // setter 必须
}
```



```xml
<bean id="bookDao" class="com.xxx.dao.impl.BookDaoImpl">
    <property name="array">
        <array>
            <value>100</value>
            <value>300</value>
            <value>500</value>
        </array>
    </property>
    <property name="list">
        <list>
            <value>hello</value>
            <value>world</value>
            <value>bye</value>
        </list>
    </property>
    <property name="set">
        <set>
            <value>喜洋洋</value>
            <value>美洋洋</value>
            <value>懒羊羊</value>
            <value>懒羊羊</value>
        </set>
    </property>
    <property name="map">
        <map>
            <entry key="username" value="zangxin"/>
            <entry key="age" value="11"/>
            <entry key="birthday" value="2000-01-01"/>
        </map>
    </property>
    <property name="properties">
        <props>
            <prop key="country">CHN</prop>
            <prop key="province">SHANGHAI</prop>
            <prop key="city">SHANGHAI</prop>
        </props>
    </property>
</bean>
<!--添加引用类型时,把value改成ref即可-->
```

### 1.4 数据源对象管理

mysql-connector-j 8.0版本可以使用的mysql server version包括5.7 8.0

![img](..\img\md-img\2024-08-01-ssm\684a2033f4849a0c9a804f3e0b4534b8.png)

com.mysql.cj.jdbc.Driver 是 mysql-connector-java 6以及以上中的

mysql配置(jdbc8.0)

```properties
jdbc.driver-class-name=com.mysql.cj.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/test?serverTimezone=Asia/Shanghai&useUnicode=true&characterEncoding=utf8&useSSL=false
jdbc.username=root
jdbc.password=root
```

#### 1.配置文件管理数据源对象

druid和c3p0数据源对象交给spring管理

```xml
<bean id="druidDataSource" class="com.alibaba.druid.pool.DruidDataSource">
    <property name="driverClassName" value="com.mysql.cj.jdbc.Driver"/>
    <property name="url" value="jdbc:mysql://localhost:3306/top_news"/>
    <property name="username" value="root"></property>
    <property name="password" value="root"></property>
</bean>

<bean id="c3p0DataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
    <property name="driverClass" value="com.mysql.cj.jdbc.Driver"/>
    <property name="jdbcUrl" value="jdbc:mysql://localhost:3306/top_news"/>
    <property name="user" value="root"/>
    <property name="password" value="root"/>
</bean>
```

maven依赖

```xml
<dependency>
    <groupId>com.mysql</groupId>
    <artifactId>mysql-connector-j</artifactId>
    <version>8.0.33</version>
</dependency>
<dependency>
    <groupId>c3p0</groupId>
    <artifactId>c3p0</artifactId>
    <version>0.9.1.2</version>
</dependency>
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid</artifactId>
    <version>1.1.16</version>
</dependency>
```

#### 2.jdbc.properites文件方式

1.在spring配置文件中开始context命名空间

![image-20240801222616215](..\img\md-img\image-20240801222616215.png)

2.利用context命名空间加载jdbc.properties文件

3.使用属性占位符${}读取properties文件中的属性

```xml
<!--system-properties-mode="NEVER" 不使用系统环境变量,windows系统环境有个username他的优先度高于${username},所以要关掉-->
<context:property-placeholder location="classpath*:jdbc.properties" system-properties-mode="NEVER"/>
```

```xml
<context:property-placeholder location="classpath*:jdbc.properties"/>
<bean id="druidDataSource" class="com.alibaba.druid.pool.DruidDataSource">
    <property name="driverClassName" value="$${driver-class-name}"/>
    <property name="url" value="${url}"/>
    <property name="username" value="${username}"></property>
    <property name="password" value="${password}"></property>
</bean>
```

```java
// 获取环境变量
Map<String, String> getenv = System.getenv();
System.out.println("username = " + getenv.get("USERNAME"));
```



```java
// 路径获取配置文件
ApplicationContext ctx = new ClassPathXmlApplicationContext("classpath:*.xml");
// 绝对路径
// ApplicationContext ctx1 = new FileSystemXmlApplicationContext("C:\\Users\\....\\src\\main\\resources\\applicationContext.xml");
// 获取bean的三种方式
ctx.getBean("bookDao");
BookDao bookDao = ctx.getBean("bookDao", BookDao.class);
BookDao bookDao1 = ctx.getBean(BookDao.class);
bookDao1.add();
```

![1629984980781](C:\Users\32929\Documents\GitHub\zangxin51.github.io\img\md-img\2024-08-01-ssm\1629984980781.png)

BeanFactory创建完毕后,所有bean均为延迟加载, ApplicationContext默认为非懒加载

通过bean标签的lazy-init属性可以配置是否懒加载

```xml
<bean id="bookDao" class="dao.impl.BookDaoImpl" lazy-init="true"/>
```

BeanFactory是所有容器的顶层接口

```java
// 使用BeanFactory
Resource resource = new ClassPathResource("applicationContext.xml");
BeanFactory bf = new XmlBeanFactory(resource);
BookDao bookDao = bf.getBean(BookDao.class);
bookDao.add();
```

### 1.5 容器总结

![1629986510487](C:\Users\32929\Documents\GitHub\zangxin51.github.io\img\md-img\2024-08-01-ssm\1629986510487.png)

![1629986848563](C:\Users\32929\Documents\GitHub\zangxin51.github.io\img\md-img\2024-08-01-ssm\1629986848563.png)

### 1.6 注解开发

#### 1.定义bean

1. 使用@Component注解, 等价的注解还有三个(Controller,Service,Repository)
2. 配置包扫描

```java
@Component("bookDao")
public class BookDaoImpl implements BookDao {}
```

```xml
<context:component-scan base-package="com.xxx.dao"/>
```

#### 2.纯注解开发

利用java类替代了ApplicationContext.xml配置文件 @ComponentScan替代了context:component-scan标签

AnnotationConfigApplicationContext获取容器对象

```java
@Configuration
@ComponentScan({"com.xxx", "com.xxx.dao"})
public class SpringConfig {}
```

```java
ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);
BookDao bookDao = ctx.getBean("bookDao", BookDao.class);
bookDao.add();
```

作用范围和声明周期

```java
@Component("bookDao")
@Scope("singleton") // 作用范围
public class BookDaoImpl implements BookDao {
    @PostConstruct // 生命周期
    public void init() {
        System.out.println("BookDaoImpl.init");
    }
    @PreDestroy // 生命周期
    public void destroy() {
        System.out.println("BookDaoImpl.destroy");
    }
}
```

#### 3.自动装配

**1.引用类型**

```java
@Service
public class BookServiceImpl implements BookService {
    @Autowired
    @Qualifier("bookDao2")
    private BookDao bookDao;
}
```

- 自动装配基于发射创建对象并暴力反射对应属性为私有属性初始化数据, 因此无需提供setter方法
- 必须要有一个无参构造器
- @Qualifier()注解不能单独使用, 要配合@Autowired一起使用

**2.基本类型**

```java
@Repository("bookDao")
@Scope("singleton")
public class BookDaoImpl implements BookDao {
    // 基本类型注入
    @Value("${name}")
    private String name;
}
```

```java
@Configuration
@ComponentScan({"com.xxx", "com.xxx.dao"})
@PropertySource("classpath:jdbc.properties") // 加载外部properties配置文件,这里不允许使用通配符
public class SpringConfig {
}	
```

#### 4.第三方bean管理&第三方依赖管理

1.使用@Bean定义第三方bean

```java
public class JdbcConfig {
    // 1.顶一个方法获取要管理的对象
    @Bean
    public DataSource dataSource() {
        DruidDataSource ds = new DruidDataSource();
        ds.setDriverClassName("com.mysql.cj.jdbc.Driver");
        ds.setUrl("jdbc:mysql://localhost:3306/top_news);
        ds.setUsername("root");
        ds.setPassword("roots");
        return ds;
    }
}
```

2.将独立的 JdbcConfig配置类加入核心配置(使用@Import注解)

```java
@Configuration
@ComponentScan("com.xxx")
@Import(JdbcConfig.class)
public class Config {}
```

3.第三方基本类型(成员变量)和引用类型(方法形参)的注入

```java
public class JdbcConfig {
    // 普通类型
    @Value("${driver-class-name}")
    private String driver;
    @Value("${url}")
    private String url;
    @Value("${username}")
    private String username;
    @Value("${password}")
    private String password;

    // 1.顶一个方法获取要管理的对象
    // 2.BookDao采用的按类型自动装配
    @Bean
    public DataSource dataSource(BookDao bookDao) {
        System.out.println(bookDao);
        DruidDataSource ds = new DruidDataSource();
        ds.setDriverClassName(driver);
        ds.setUrl(url);
        ds.setUsername(username);
        ds.setPassword(password);
        return ds;
    }
}
```

##### 5.注解开发总结

![1630134786448](C:\Users\32929\Documents\GitHub\zangxin51.github.io\img\md-img\2024-08-01-ssm\1630134786448.png)

### 1.7 spring整合mysbatis

整合依赖

```xml
<!--整合mybatis专用包: mybatis-spring spring-jdbc-->
<dependency>
    <groupId>org.mybatis</groupId>
    <artifactId>mybatis-spring</artifactId>
    <version>2.1.1</version>
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-jdbc</artifactId>
    <version>5.3.30</version>
</dependency>
<dependency>
    <groupId>org.mybatis</groupId>
    <artifactId>mybatis</artifactId>
    <version>3.5.6</version>
</dependency>
<dependency>
    <groupId>com.mysql</groupId>
    <artifactId>mysql-connector-j</artifactId>
    <version>8.0.33</version>
</dependency>
<dependency>
    <groupId>com.mysql</groupId>
    <artifactId>mysql-connector-j</artifactId>
    <version>8.0.33</version>
</dependency>
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid</artifactId>
    <version>1.1.16</version>
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>5.3.30</version>
</dependency>
```

mybatis配置类

```java
public class MybatisConfig {
    // 构造sessionFactory, 数据源采用自动装配
    @Bean
    public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource) {
        SqlSessionFactoryBean ssfb = new SqlSessionFactoryBean();
        ssfb.setTypeAliasesPackage("com.xxx.bean");
        ssfb.setDataSource(dataSource);
        return ssfb;
    }
	// mapper扫描
    @Bean
    public MapperScannerConfigurer mapperScannerConfigurer() {
        MapperScannerConfigurer msc = new MapperScannerConfigurer();
        msc.setBasePackage("com.xxx.dao");
        return msc;
    }
}
```

jdbc数据源

```java
public class JdbcConfig {
    // 普通类型
    @Value("${jdbc.driver-class-name}")
    private String driver;
    @Value("${jdbc.url}")
    private String url;
    @Value("${jdbc.username}")
    private String username;
    @Value("${jdbc.password}")
    private String password;

    @Bean
    public DataSource dataSource() {
        DruidDataSource ds = new DruidDataSource();
        ds.setDriverClassName(driver);
        ds.setUrl(url);
        ds.setUsername(username);
        ds.setPassword(password);
        return ds;
    }
}
```

spring核心配置类

```java
@Configuration
@ComponentScan("com.xxx")
@PropertySource("classpath:jdbc.properties")
@Import({JdbcConfig.class, MybatisConfig.class})
public class SpringConfig {}
```

测试

```java
ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);
AccountService accountService = ctx.getBean(AccountService.class);
Account account = accountService.findById(1);
System.out.println("account = " + account);
```

### 1.8 Junit整合

依赖

```xml
<dependency>
    <groupId>junit</groupId>
    <artifactId>junit</artifactId>
    <version>4.12</version>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-test</artifactId>
    <version>5.3.30</version>
</dependency>
```

指定类运行器(@RunWith)和spring配置位置(@ContextConfiguration)

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes = SpringConfig.class)
public class AccountServiceImplTest {
    @Autowired
    private AccountService accountService;
    
    @Test
    public void findById() {
        System.out.println(accountService.findById(1));
    }
    
    @Test
    public void findAll() {
        System.out.println(accountService.findAll());
    }
}	
```

### 1.9 AOP

#### 1.aop基本概念

aspect oriented programming 面向切面编程

作用: 在不改动原始设计的基础上为其进行功能增强

实现: 代理模式

连接点(joinPonit):所有方法,执行过程中任意位置

切入点(pointcut):匹配连接点的式子

范围:切入点是连接点的子集

通知(advice): 在切入点执行的操作,也就是共性操作,或者说增强的功能

切面(Aspect): 描述通知与切入点的对应关系

#### 2.quickstart

目标: 在接口执行时打印系统当前时间

依赖

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>5.3.30</version>
</dependency>
<dependency>
    <groupId>org.aspectj</groupId>
    <artifactId>aspectjweaver</artifactId>
    <version>1.9.7</version>
</dependency>
```

**切面类(@Aspect注解)**

```java
@Aspect  // 切面
@Component 
public class MyAdvice {
    @Pointcut("execution(void com.xxx.dao.BookDao.update())")  // 切入点
    private void pt() {} //  切入点方法 

    @Before("pt()") // 通知
    public void method() {
        System.out.println(System.currentTimeMillis());
    }
}
```

在配置类中**开启aspectj自动代理**

```java
@Configuration
@ComponentScan("com.xxx")
@EnableAspectJAutoProxy
public class SpringConfig {}
```

注意: 切入点方法必须是私有方法,空参,无返回值

#### 3.aop工作流程

1. spring容器启动
2. 读取所有切面配置中的切入点
3. 初始化bean,判断bean对应的类中的方式是否匹配到任意切入点
   - 匹配失败,创建对象
   - 匹配成功,创建原始对象的代理对象
4. 获取bean的执行方法
   - 获取bean, 调用方法执行
   - 获取bean是代理对象时, 根据代理对象的运行模式执行增强的内容(包括原来的内容)

AOP核心概念: 代理模式

- 目标对象
- 代理对象

#### 4.AOP切入点表达式

切入点: 要增强的方法

切入点: 要进行增强的方法的描述方式

切入点表达式: execution (访问控制修饰符 返回值 包名.类/接口名.方法名(参数) 异常名)

```java
execution(void com.xxx.dao.impl.BookDaoImpl.update())
```

通配符: 

\* : 单个独立的任意符号,可以独立出现,也可以作为前缀和后缀的通配符出现

.. : 多个连续的任意符号, 可以独立出现, 常用于简化包名和参数的书写

\+ : 专用与匹配子类

例子:

com.xxx.dao.impl.BookDaoImpl#update()的匹配

```java
@Pointcut("execution(void com.xxx.dao.impl.BookDaoImpl.update())")  // yes
@Pointcut("execution(* com.xxx.dao.impl.BookDaoImpl.update(*))") // no
@Pointcut("execution(void com.*.*.*.*.update())") // yes
@Pointcut("execution(void com.*.*.*.update())") //yes
@Pointcut("execution(* *..*(..))")  //yes 匹配全部方法
@Pointcut("execution(* *..u*(..))")  //yes
@Pointcut("execution(* com.xxx.*.*Service.*(..))") // 匹配所有com.xxx.service层方法
```

书写技巧

- 按照代码规范书写
- 描述切入点通常描述接口, 而不采用实现类
- 访问控制符针对接口开发均采用public描述(可以省略)
- 返回值类型对于增删改类使用精准类型加速匹配, 对查询使用*通配符快速描述
- 包名尽量不用..匹配,效率过低,通常采用*做单个包描述,或精准匹配
- 接口名/类名采用*匹配, 如UserService书写成\*Service
- 方法名书写以动词进行精准匹配,名词采用\*匹配, 如getById书写成getBy*,selectAll写成selectAll
- 参数规则复杂, 根据业务方法灵活调整
- 通常不使用异常作为匹配规则

#### 5.AOP通知类型

```java
// 准备切入点
@Pointcut("execution(void com.xxx.dao.BookDao.update())")
private void pt() {}
```

前置通知

```java
@Before("pt()")
public void before() {
    System.out.println("MyAdvice.before");
}
```

后置通知

```java
@After("pt()")
public void after() {
    System.out.println("MyAdvice.after");
}
```

环绕通知(重点 **ProceedingJoinPoint参数, 调用proceed方法,获取返回值, 必须返回值Object**)

```java
@Around("pt2()")
public Object around(ProceedingJoinPoint pjp) throws Throwable {
    System.out.println("MyAdvice.around before");
    //  表示对原始操作的调用
    Object result = pjp.proceed();
    System.out.println("MyAdvice.around after");
    return result;
}
```

返回后通知, 与after的区别是, 原方法抛出异常后, afterReturning中断, after执行完毕

```java
@AfterReturning("pt2()")
public void afterReturning() {
    System.out.println("MyAdvice.afterReturning");
}
```

异常通知(只有在发生异常时,才调用)

```java
@AfterThrowing("pt2()")
public void afterThrowing() {
    System.out.println("MyAdvice.afterThrowing");
}
```

**Around通知总结**

1. 环绕通知必须依赖形参ProceedingJoinPoint才能实现对原始方法的调用，进而实现原始方法调用前后同时添加通知
2. 通知中如果未使用ProceedingJoinPoint对原始方法进行调用将跳过原始方法的执行
3. 对原始方法的调用可以不接收返回值，通知方法设置成void即可，如果接收返回值，最好设定为Object类型
4. 原始方法的返回值如果是void类型，通知方法的返回值类型可以设置成void,也可以设置成Object
5. 由于无法预知原始方法运行后是否会抛出异常，因此环绕通知方法必须要处理Throwable异常

#### 6.**测量业务层接口执行效率(耗时)**

需求: 任意业务层接口执行事件均可显示其执行效率

分析:

1. 业务功能: 业务层接口执行前后分别记录时间,求差值得到执行效率
2. 通知类型选择前后均可以增强的类型----->**环绕通知**

切面类

```java
@Aspect
@Component
public class ProjectAdvice {
    @Pointcut("execution(* com.xxx.service.*Service.*(..))") // 匹配业务层所有方法
    private void servicePt() {
    }

    @Around("ProjectAdvice.servicePt()")
    public void runSpeed(ProceedingJoinPoint pjp) throws Throwable {
        // 获取方法名和类名
        Signature signature = pjp.getSignature();
        String className = signature.getDeclaringTypeName();
        String methodName = signature.getName();
        long start = System.currentTimeMillis();
        for (int i = 0; i < 10000; i++) {
            pjp.proceed();
        }
        long end = System.currentTimeMillis();
        System.out.println("业务层接口" + className + "." + methodName + "万次执行时间: " + (end - start) + "ms");
    }
}
```

配置类

```java
@Configuration
@ComponentScan("com.xxx")
@PropertySource("classpath:jdbc.properties")
@Import({JdbcConfig.class, MybatisConfig.class})
@EnableAspectJAutoProxy
public class SpringConfig {}
```

测试类

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes = SpringConfig.class)
public class AccountServiceImplTest {
    @Autowired
    private AccountService accountService;

    @Test
    public void findById() {
        accountService.findById(1);
    }

    @Test
    public void findAll() {
        accountService.findAll();
    }
}
// output
// 业务层接口com.xxx.service.AccountService.findAll万次执行时间: 1498ms
// 业务层接口com.xxx.service.AccountService.findById万次执行时间: 1015ms
```

#### 7.AOP获取通知的数据

获取切入点方法的参数

- JoinPoint: 适用于前置,后置,返回后,异常抛出后
- **ProceedingJoinPoint**: 适用于环绕通知

获取切入点方法返回值

- 返回后通知
- 环绕通知

获取切入点方法运行异常信息

- 抛出异常后通知
- 环绕通知

```java
@Pointcut("execution(int com.xxx.dao.BookDao.update(..))")
private void pt2() {
}

@Before("pt2()")
public void before(JoinPoint jp) {
    Object[] args = jp.getArgs();
    System.out.println("before args = " + Arrays.toString(args));
    System.out.println("MyAdvice.before");
}

@After("pt2()")
public void after(JoinPoint jp) {
    Object[] args = jp.getArgs();
    System.out.println("after args = " + Arrays.toString(args));
    System.out.println("MyAdvice.after");
}

@Around("pt2()")
public Object around(ProceedingJoinPoint pjp) throws Throwable {
    Object[] args = pjp.getArgs();
    System.out.println("around args = " + Arrays.toString(args));
    args[0] = 666;
    System.out.println("MyAdvice.around before");
    Object result = pjp.proceed(args);
    System.out.println("MyAdvice.around after ret=" + result);
    return result;
}

@AfterReturning(value = "pt2()", returning = "ret")
public void afterReturning(JoinPoint jp, Object ret) {
    Object[] args = jp.getArgs();
    System.out.println("afterReturning args = " + Arrays.toString(args));
    System.out.println("MyAdvice.afterReturning ret=" + ret);

}

@AfterThrowing(value = "pt2()", throwing = "t")
public void afterThrowing(Throwable t) {
    System.out.println("MyAdvice.afterThrowing: t=" + t);
}
```

#### 8.网盘密码数据兼容案例

需求: 密码输入时去除尾部多余的空格

分析:

1. 在所有业务方法执行之前对所有输入的参数进行格式处理 trim()
2. 使用处理后的参数调用原始方法----环绕通知中存在对原始方法的调用

 配置类

```java
@Configuration
@ComponentScan("com.xxx")
@EnableAspectJAutoProxy
public class SpringConfig {}
```

切面类

```java
@Component
@Aspect
public class DataAdvice {
    @Pointcut("execution(boolean com.xxx.service.ResourceService.openURL(*,*))")
    private void servicePt() {}

    @Around("DataAdvice.servicePt()")
    public Object trimStr(ProceedingJoinPoint pjp) throws Throwable {
        Object[] args = pjp.getArgs();
        // 改参数
        for (int i = 0; i < args.length; i++) {
            // 判断参数是不是字符串
            if (args[i].getClass().equals(String.class)) {
                args[i] = args[i].toString().trim();
            }
        }
        // 将改的参数进去,必须
        Object ret = pjp.proceed(args);
        return ret;
    }
}
```

测试

```java
AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);
ResourceService resourceService = ctx.getBean(ResourceService.class);
boolean isSuccess = resourceService.openURL("http://pan.baidu.com", " root ");
System.out.println("isSuccess = " + isSuccess);
// output
// password.length = 4
// isSuccess = true
```

### 1.10 Spring事务

#### 1.Spring事务概念

事务作用: 在数据库层面保障一系列的数据库操作同时成功/失败

Spring事务作用: 在数据层或业务层保障一系列的数据库操作同时成功/失败

Spring事务接口: 

```java
public interface PlatformTransactionManager extends TransactionManager {
	void commit(TransactionStatus status) throws TransactionException;
	void rollback(TransactionStatus status) throws TransactionException;
}
```

#### 2.案例: 银行账户转账(事务quickstart)

需求:实现任务两个账户间转账操作

需求微缩: A账户减钱, B账户加钱

分析:

1. 数据层: 指定账户减钱outMoney, 指定账户加钱(inMoney)
2. 业务层提供转账操作(transfer), 调用加钱和减钱操作
3. 提供两个账号和操作金额执行转账操作
4. 基于Spring整合Mybatis环境搭建上述操作

结果分析:

1. 程序正常执行时, 账号金额A加B减
2. 程序出现异常时, 转账失败, 但是之前操作成功, 异常之后操作失败, 业务整体失败

使用Spring事务quickstart

1.在业务层上添加Spring事务管理

```java
@Transactional
void transfer(String out, String in, Double money);
```

@Transactional通常加在接口方法上, 而不是实现类上, 降低耦合

注解式事务可以添加业务方法上表示当前方法开启事务, 也可以添加到接口上, 表示当前接口中所有方法开启事务

2.设置事务管理器

```java
// 定义事务管理器, mybatis使用的是jdbc事务管理器
@Bean
public PlatformTransactionManager transactionManager(DataSource dataSource) {
    DataSourceTransactionManager tm = new DataSourceTransactionManager();
    tm.setDataSource(dataSource);
    return tm;
}
```

3.开启注解式事务驱动

```java
@Configuration
@ComponentScan("com.xxx")
@Import({MybatisConfig.class,  JdbcConfig.class})
@PropertySource("classpath:jdbc.properties")
@EnableTransactionManagement // 开启注解事务
public class SpringConfig {}
```

案例代码

dao

```java
public interface AccountDao {
    @Update("update tbl_account set money = money + #{money}  where name = #{name}")
    void inMoney(@Param("name") String name, @Param("money") Double money);

    @Update("update tbl_account set money = money - #{money}  where name = #{name}")
    void outMoney(@Param("name") String name, @Param("money") Double money);
}
```

service

```java
public interface AccountService {
    @Transactional
    void transfer(String out, String in, Double money);
}
```

```java
@Service
public class AccountServiceImpl implements AccountService {
    @Autowired
    private AccountDao accountDao;

    @Override
    public void transfer(String out, String in, Double money) {
        accountDao.outMoney(out, money);
        int i = 1/0;
        accountDao.inMoney(in, money);
    }
}
```

测试类

```java
public class App {
    public static void main(String[] args) {
        ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);
        AccountService accountService = ctx.getBean(AccountService.class);
        accountService.transfer("tom","jerry",100.0);
    }
}
```

bean

```java
public class Account {
    private Integer id;
    private String name;
    private Double money;
}
```

配置类

```java
public class JdbcConfig {
    // 普通类型
    @Value("${jdbc.driver-class-name}")
    private String driver;
    @Value("${jdbc.url}")
    private String url;
    @Value("${jdbc.username}")
    private String username;
    @Value("${jdbc.password}")
    private String password;
    // 定义数据源
    @Bean
    public DataSource dataSource() {
        DruidDataSource ds = new DruidDataSource();
        ds.setDriverClassName(driver);
        ds.setUrl(url);
        ds.setUsername(username);
        ds.setPassword(password);
        return ds;
    }
    // 定义事务管理器
    @Bean
    public PlatformTransactionManager transactionManager(DataSource dataSource) {
        DataSourceTransactionManager tm = new DataSourceTransactionManager();
        tm.setDataSource(dataSource);
        return tm;
    }
}
```

```java
public class MybatisConfig {
    // 构造sessionFactory, 数据源采用自动装配
    @Bean
    public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource) {
        SqlSessionFactoryBean ssfb = new SqlSessionFactoryBean();
        ssfb.setTypeAliasesPackage("com.xxx.bean");
        ssfb.setDataSource(dataSource);
        return ssfb;
    }
    // mapper扫描
    @Bean
    public MapperScannerConfigurer mapperScannerConfigurer() {
        MapperScannerConfigurer msc = new MapperScannerConfigurer();
        msc.setBasePackage("com.xxx.dao");
        return msc;
    }
}
```

```java
@Configuration
@ComponentScan("com.xxx")
@Import({MybatisConfig.class,  JdbcConfig.class})
@PropertySource("classpath:jdbc.properties")
@EnableTransactionManagement // 开启注解事务
public class SpringConfig {}

```

```properties
jdbc.driver-class-name=com.mysql.cj.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/spring_db?serverTimezone=Asia/Shanghai&useUnicode=true&characterEncoding=utf8&useSSL=false
jdbc.username=root
jdbc.password=root
```

```sql
create schema if not exists spring_db collate utf8mb4_unicode_ci;
DROP TABLE IF EXISTS `tbl_account`;
CREATE TABLE `tbl_account` (
  `id` int(11) NOT NULL,
  `name` varchar(35) DEFAULT NULL,
  `money` double DEFAULT NULL,
  PRIMARY KEY (`id`)
);
INSERT INTO `tbl_account` VALUES (1,'tom',900),(2,'jerry',1100);
```

#### 3.spring事务角色

事务管理员: 发起事务方, 在Spring中通常指代业务层开始事务的方法

事务协调员: 加入事务方, 在Spring中通常指代数据层方法, 也可是业务层方法

事务的统一管理必须使用同一个数据源

#### 4.事务配置

![1630250069844](C:\Users\32929\Desktop\cai\backend\ssm\课程笔记\基础框架8笔记\Spring笔记\spring_day03\assets\1630250069844.png)

上面这些属性都可以在`@Transactional`注解的参数上进行设置。

* readOnly：true只读事务，false读写事务，增删改要设为false,查询设为true。

* timeout:设置超时时间单位秒，在多长时间之内事务没有提交成功就自动回滚，-1表示不设置超时时间。

* rollbackFor:当出现指定异常进行事务回滚

* noRollbackFor:当出现指定异常不进行事务回滚

  * 思考:出现异常事务会自动回滚，这个是我们之前就已经知道的

  * noRollbackFor是设定对于指定的异常不回滚，这个好理解

  * rollbackFor是指定回滚异常，对于异常事务不应该都回滚么，为什么还要指定?

    * 这块需要更正一个知识点，并不是所有的异常都会回滚事务，比如下面的代码就不会回滚

```java
public interface AccountService {
    /**
     * 转账操作
     * @param out 传出方
     * @param in 转入方
     * @param money 金额
     */
    //配置当前接口方法具有事务
    public void transfer(String out,String in ,Double money) throws IOException;
}

@Service
public class AccountServiceImpl implements AccountService {

    @Autowired
    private AccountDao accountDao;
	@Transactional
    public void transfer(String out,String in ,Double money) throws IOException{
        accountDao.outMoney(out,money);
        //int i = 1/0; //这个异常事务会回滚
        if(true){
            throw new IOException(); //这个异常事务就不会回滚
        }
        accountDao.inMoney(in,money);
    }

}
```

出现这个问题的原因是，Spring的事务只会对`Error异常`和`RuntimeException异常`及其子类进行事务回滚，其他的异常类型是不会回滚的，对应IOException不符合上述条件所以不回滚
    

* 此时就可以使用rollbackFor属性来设置出现IOException异常不回滚

```java
@Service
public class AccountServiceImpl implements AccountService {

    @Autowired
    private AccountDao accountDao;
	 @Transactional(rollbackFor = {IOException.class})
    public void transfer(String out,String in ,Double money) throws IOException{
        accountDao.outMoney(out,money);
        //int i = 1/0; //这个异常事务会回滚
        if(true){
            throw new IOException(); //这个异常事务就不会回滚
        }
        accountDao.inMoney(in,money);
    }

}
```

* rollbackForClassName等同于rollbackFor,只不过属性为异常的类全名字符串

* noRollbackForClassName等同于noRollbackFor，只不过属性为异常的类全名字符串

* isolation设置事务的隔离级别

  * DEFAULT   :默认隔离级别, 会采用数据库的隔离级别
  * READ_UNCOMMITTED : 读未提交
  * READ_COMMITTED : 读已提交
  * REPEATABLE_READ : 重复读取
  * SERIALIZABLE: 串行化

介绍完上述属性后，还有最后一个事务的传播行为，为了讲解该属性的设置，我们需要完成下面的案例。

#### 5.案例: 转账业务追加日志

需求: 实现任意两个账户之间转账操作, 并对每次转账操作在数据库进行留痕

需求微缩: A账户减钱, B账户价钱, 数据库要记录日志

分析:

1. 基于转账操作案例添加日志模块,实现数据库中记录日志
2. 业务层转账操作(transfer), 调用减钱, 价钱与记录日志功能

预期效果:

无论转账是否成功, 均进行转账日志留痕

新增表 tbl_log

```sql
create table if not exists spring_db.tbl_log
(
    info        varchar(100) null comment '日志信息',
    create_date datetime     null comment '创建时间',
    id          int auto_increment
        primary key
)
    comment '转账日记记录表' collate = utf8mb4_unicode_ci;
```

在logService和AccountService都加上@Transactional注解后, 发现失败后tbl_log日志和tbl_account的金额都会滚

这样就不满足要求: 无论转账是否成功, 均进行转账日志留痕, 要实现该功能需要事务传播性功能: 

propagation = Propagation.*REQUIRES_NEW*

```java
public interface LogService {
    @Transactional
    void log(String out, String in, Double money);
}
```

```java
public interface AccountService {
    @Transactional
    void transfer(String out, String in, Double money);
}
```

```java
@Service
public class AccountServiceImpl implements AccountService {
    @Autowired
    private AccountDao accountDao;
    @Autowired
    private LogService logService;
    @Override
    public void transfer(String out, String in, Double money) {
        try {
            accountDao.outMoney(out, money);
            int i = 1/0;
            accountDao.inMoney(in, money);
        } catch (Exception e) {
            // 这里异常必须抛出去,否则事务不生效
            throw new RuntimeException(e);
        } finally {
            logService.log(out, in, money);
        }
    }
}

```

![1630254257628](C:\Users\32929\Documents\GitHub\zangxin51.github.io\img\md-img\2024-08-01-ssm\1630254257628.png)

## 2. SpringMVC

### 2.1概述

springmvc <---> 和servlet等价, 都是表现层技术

表现层: springmvc/servlet

业务层:..

dao层: jdbc/mybatis/hibernate

springmvc是一种表现层框架技术

springmvc用于进行表现层功能开发

### 2.2 springmvc quickstart(注意依赖版本号)

**1.依赖 jdk1.8 + tomcat8(本地tomcat) tomcat10跑不起来, spring依赖使用5.3.0以下的**

```xml
    <dependencies>
        <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>javax.servlet-api</artifactId>
            <version>3.1.0</version>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-webmvc</artifactId>
            <version>5.2.10.RELEASE</version>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
            <version>5.2.10.RELEASE</version>
            <scope>compile</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.tomcat.maven</groupId>
                <artifactId>tomcat7-maven-plugin</artifactId>
                <version>2.1</version>
                <configuration>
                    <port>80</port>
                    <path>/</path>
                </configuration>
            </plugin>
        </plugins>
    </build>
```

2.创建springMVC控制器(等同于Servlet)

```java
@Controller
public class UserController {
    @RequestMapping("/save")
    @ResponseBody
    public String save() {
        System.out.println("user save");
        return "{'module':'springmvc'}";
    }
}
```

3.spring配置类

```java
@Configuration
@ComponentScan("com.xxx.controller")
public class SpringMvcConfig {}
```

4.初始化Servlet容器, 加在springMVC环境, 并设置MVC技术处理的请求

定义一个servlet容器启动的配置类, 在里面加在spring的配置(有了这个就可以删除web.xml文件)

```java
public class ServletContainerInitConfig extends AbstractDispatcherServletInitializer {
    // 加载springmvc容器
    @Override
    protected WebApplicationContext createServletApplicationContext() {
        AnnotationConfigWebApplicationContext ctx = new AnnotationConfigWebApplicationContext();
        ctx.register(SpringMvcConfig.class);
        return ctx;
    }
    // 设置哪些请求归属springmvc处理
    @Override
    protected String[] getServletMappings() {
        return new String[]{"/"};
    }
    // 加载spring容器配置
    @Override
    protected WebApplicationContext createRootApplicationContext() {
        return null;
    }
}
```

入门案例工作流程分析

启动服务的过程

1. 服务启动, 执行ServletContainerInitConfig类型, 初始web化容器
2. 执行createServletApplicationContext()方法, 创建WebApplicationContext对象
3. 加载SpringMVCConfig配置类型(包扫描)
4. 执行ComponentScan加载对应的bean
5. 加载UserController, 每个@RequestMapping的名称对应一个具体方法
6. 执行getServletMappings方法，设定SpringMVC拦截请求的路径规则

单次请求过程

1. 发送请求`http://localhost/save`
2. web容器发现该请求满足SpringMVC拦截规则，将请求交给SpringMVC处理
3. 解析请求路径/save
4. 由/save匹配执行对应的方法save(）
   * 上面的第五步已经将请求路径和方法建立了对应关系，通过/save就能找到对应的save方法
5. 执行save()
6. 检测到有@ResponseBody直接将save()方法的返回值作为响应体返回给请求方



### 2.3 bean加载与控制(分容器加载)

SpringMVC相关bean (表现层bean)

Spring控制的bean

- 业务bean (Service)
- 功能bean (DataSource等)

因功能不同, 如何避免Spring错误加载到SpringMVC的bean--加载Spring控制的bean的时候排除掉SpringMVC控制的bean

spring包扫描dao和service

方式一: 精确扫描Service和dao

方式二: 扫描所有包,排除controller

```java
@Configuration
//@ComponentScan({"com.xxx.service", "com.xxx.dao"})
@ComponentScan(value = "com.xxx",
        excludeFilters = @ComponentScan.Filter(
                type = FilterType.ANNOTATION,
                classes = Controller.class
        )
)
@PropertySource("classpath:jdbc.properties")
@Import({JdbcConfig.class, MybatisConfig.class})
public class SpringConfig {}

```

SpringMVC扫描controller

```java
@Configuration
@ComponentScan("com.xxx.controller")
public class SpringMvcConfig {}
```

注册Spring和SpringMVC到web容器中

```java
public class ServletContainersInitConfig1 extends AbstractAnnotationConfigDispatcherServletInitializer {
    @Override
    protected Class<?>[] getRootConfigClasses() {
        return new Class[]{SpringConfig.class};
    }
    @Override
    protected Class<?>[] getServletConfigClasses() {
        return new Class[]{SpringMvcConfig.class};
    }
    @Override
    protected String[] getServletMappings() {
        return new String[]{"/"};
    }
}
```

### 知识点1：@ComponentScan

| 名称     | @ComponentScan                                               |
| -------- | ------------------------------------------------------------ |
| 类型     | 类注解                                                       |
| 位置     | 类定义上方                                                   |
| 作用     | 设置spring配置类扫描路径，用于加载使用注解格式定义的bean     |
| 相关属性 | excludeFilters:排除扫描路径中加载的bean,需要指定类别(type)和具体项(classes)<br/>includeFilters:加载指定的bean，需要指定类别(type)和具体项(classes) |
