---
layout:     post
title:      "SSM框架"
subtitle:   "ssm"
date:       2024-08-01 11:58:00
author:     "zangxin"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
---

**SSM**

## 1.spring

用途: 简化javaweb开发

- [ ] **IOC**
- [ ] **AOP**(事务)

官网: spring.io

Spring Framework

Spring Boot

### 1.1spring 架构

![image-20240801091412451](\img\md-img\image-20240801091412451.png)

### 1.2 IOC

**IOC**: inversion of control 控制反转, 使用对象时由自己**new**对象, 转换成, 由**外部**提供对象, 对象创建的控制权限转移到**外部**.

**IOC**容器: spring提供了一个容器, 就是上面的**外部**. IOC容器负责对象的创建, 初始化的工作, 被创建的对象在IOC容器中称为Bean.

**DI**: dependency injection 依赖注入,

- 在容器中建立bean与bean之间的依赖关系, 自动注入bean

**解耦**

- 使用IOC容器管理bean (IOC)
- 在IOC容器中将有依赖关系的bean进行绑定(DI)
- 效果: 使用对象时可以从IOC容器中获取, 并且bean已经绑定对其他bean的依赖关系
- **不用new对象, 依赖自动处理好**

#### 1.2.1 spring quickstart

1. 管理什么? (service与dao)
2. 如何将管理对象告知IOC容器? (配置)
3. 如何获取IOC容器? (接口)
4. 如何从IOC中获取bean? 
5. 如何使用spring? (pom.xml)

##### 1.配置maven坐标

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>5.3.30</version>
</dependency>
```

##### 2.在resources目录下配置applicationContext.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean class="com.xxx.spring.dao.impl.BookDaoImpl" id="bookDao"/>

    <bean class="com.xxx.spring.servcie.impl.BookServiceImpl" id="bookService"></bean>
    
</beans>
```

##### 3.**从IOC容器获取bean测试**

```java
public class APP {
    public static void main(String[] args) {
        // 获取容器
        ApplicationContext context = new 	ClassPathXmlApplicationContext("classpath:*.xml");
        BookDao bookDao = context.getBean("bookDao", BookDao.class);
        bookDao.addBook();

        BookService bookService = (BookService) context.getBean("bookService");
        bookService.addBook();
    }
}
```

##### 4.DI测试

```java
public class BookServiceImpl implements BookService {
    // 不用new对象了,只用声明有这个属性
    private BookDao bookDao;

    @Override
    public void addBook() {
        bookDao.addBook();
        System.out.println("add success [BookServiceImpl]");

    }
	// 必须添加setter方法
    public void setBookDao(BookDao bookDao) {
        this.bookDao = bookDao;
    }
}
```

绑定service和dao的关系

```xml
<bean class="com.xxx.spring.dao.impl.BookDaoImpl" id="bookDao"/>

<!-- 配置service与dao的关系, 绑他两的关系 -->
<bean class="com.xxx.spring.servcie.impl.BookServiceImpl" id="bookService">
    <property name="bookDao" ref="bookDao"></property>
</bean>
```

#### 1.2.2 bean的配置

bean标签的属性

id和name效果相同, ref=name/id和ctx.get(name/id)

property:设置属性,利用setter方法

scop:  决定ctx.get()出来对象是不是同一个

- singleton 单例
- prototype 非单例
- 适合单例的对象: 表现层对象, 业务层,dao层,工具类, 不适合的: 请求对象/属性经常变化



#### 1.2.3bean的实例化

##### **1.无参构造方法**

暴力破解反射,私有构造器也可以造对象 ,但是必须提供无参构造器, 否则会异常:

No default constructor found; nested exception is java.lang.NoSuchMethodException: com.xxx.spring.dao.impl.BookDaoImpl.\<init>()

```java
try {
    BookDao obj = (BookDao) clazz.newInstance();
    obj.addBook();
} catch (Exception e) {}
```

##### 2.静态工厂

```xml
<!--  使用静态工厂实例化bean,class写工厂类  -->
<bean class="com.xxx.spring.factory.BookDaoFactory" id="bookDao" factory-method="getBookDao"/>
```

```java
// 静态工厂
public class BookDaoFactory {
    public static BookDao getBookDao() {
        return new BookDaoImpl();
    }
}
```

##### 3.实例工厂

```xml
<!--  实例工厂  -->
<bean id="instanceFactory" class="com.xxx.spring.factory.BookDaoInstanceFactory"/>
<bean id="bookDao" factory-method="getBookDao" factory-bean="instanceFactory"/>
```

```java
// 实例工厂
public class BookDaoInstanceFactory {
    public  BookDao getBookDao() {
        return new BookDaoImpl();
    }
}
```

4. FactoryBean 实例工厂的简化(配置两个bean简化一个bean)  实现FactoryBean接口

```xml
    <!-- FactoryBean方式 -->
    <bean id="bookDao" class="com.xxx.spring.factory.BookDaoFactoryBean"/>	
```

```java
public class BookDaoFactoryBean implements FactoryBean<BookDao> {
    // 代替原始实例工厂中创建对象的方法
    public BookDao getObject() throws Exception {
        return new BookDaoImpl();
    }

    public Class<?> getObjectType() {
        return BookDao.class;
    }
}
```

1.2.4bean的生命周期

- 初始化容器
  1. 创建对象
  2. 执行构造方法
  3. 执行属性注入(setter)
  4. 执行bean初始化方法 (init-method  InitializingBean接口的afterPropertiesSet方法)
- 使用bean
  1. 执行业务操作
- 关闭/销毁容器
  1. 执行bean销毁方法 (DisposableBean.destroy()方法)

bean的销毁方式两种 (ApplicationContext的子接口ConfigurableApplicationContext下面两个方法)

ctx.close()

// 注册关闭钩子

ctx.registerShutdownHook()

### 1.3 DI 依赖注入

#### 1.setter和构造器注入

- 依赖注入的方式

  1. 普通方法
  2. 构造方法

- 注入的类型

  1. 引用类型
  2. 简单类型(含String)

- **依赖注入方式 (2*2 四种)**

  - 1.setter注入(**用property标签** **setter方法必须**)

    - **简单类型 (value)**

      ```xml
      <property name="databaseUrl" value="jdbc:mysql://localhost:3306/top_news"></property>
      ```

      

    - **引用类型(ref)**

      ```xml
      <property name="bookDao" ref="bookDao"></property>
      ```

  - 构造器注入(必须有全部参数构造器, 可以没有空参构造器)

    - 简单类型(**用constructor-arg标签**)

    - 引用类型


```xml
<!--  形参名要和构造器一致,形参耦合问题  -->
<bean id="userService" class="com.xxx.spring.servcie.impl.UserServiceImpl">
  <constructor-arg name="username" value="root"></constructor-arg>
  <constructor-arg name="userDao" ref="userDao"></constructor-arg>
</bean>

<!--  按类型注入 不靠谱的解决方法 -->
<bean id="userService" class="com.xxx.spring.servcie.impl.UserServiceImpl">
  <constructor-arg type="com.xxx.spring.dao.UserDao" ref="userDao"></constructor-arg>
  <constructor-arg type="java.lang.String" value="root"></constructor-arg>
</bean>

<!--  按参数位置 费力的解决方法 -->
<bean id="userService" class="com.xxx.spring.servcie.impl.UserServiceImpl">
  <constructor-arg index="0" ref="userDao"></constructor-arg>
  <constructor-arg index="1" value="root"></constructor-arg>
</bean>

<bean id="userDao" class="com.xxx.spring.dao.impl.UserDaoImpl"/>
```



#### 2.依赖注入方式选择

1. 强制依赖使用构造器进行, 使用setter有概率不进行注入导致null对象出现
2. 可选依赖使用setter注入进行,灵活性强
3. spring倡导使用构造器,第三方框架内部大多数采用构造器注入进行数据初始化,相对严谨
4. 如果有必要可以二者一起用
5. 根据实际情况, 没有setter方法就只能用构造器
6. 自己开发的模块使用setter注入(简单好用)

#### 3.依赖自动装配 autowire

1. 按类型 (autowire="byType") 

   ioc找到的目标类型应只有一个 

   需要setter方法

   ```xml
   <bean class="com.xxx.spring.servcie.impl.BookServiceImpl" id="bookService" autowire="byType">
   ```

2. 按名称装配: (autowire="byName")  名称指的是setter方法的名字

   ```xml
   <!-- 配置service与dao的关系, 绑他两的关系 -->
   <bean class="com.xxx.spring.servcie.impl.BookServiceImpl" id="bookService" autowire="byName">
   ```

自动装配的优先级低于setter注入和构造器注入, 同时出现自动装配失效

优先选择按类型自动装配, 按名称自动装配不推荐使用,使用名称耦合度提高了

#### 4.集合注入

数组, list, set, map, properties

```java
public class BookDaoImpl implements BookDao {
    private int[] array;

    private List<String> list;
    private Set<String> set;

    private Map<String, String> map;
    private Properties properties;

    // setter 必须
}
```



```xml
<bean id="bookDao" class="com.xxx.dao.impl.BookDaoImpl">
    <property name="array">
        <array>
            <value>100</value>
            <value>300</value>
            <value>500</value>
        </array>
    </property>
    <property name="list">
        <list>
            <value>hello</value>
            <value>world</value>
            <value>bye</value>
        </list>
    </property>
    <property name="set">
        <set>
            <value>喜洋洋</value>
            <value>美洋洋</value>
            <value>懒羊羊</value>
            <value>懒羊羊</value>
        </set>
    </property>
    <property name="map">
        <map>
            <entry key="username" value="zangxin"/>
            <entry key="age" value="11"/>
            <entry key="birthday" value="2000-01-01"/>
        </map>
    </property>
    <property name="properties">
        <props>
            <prop key="country">CHN</prop>
            <prop key="province">SHANGHAI</prop>
            <prop key="city">SHANGHAI</prop>
        </props>
    </property>
</bean>
<!--添加引用类型时,把value改成ref即可-->
```

### 1.4 数据源对象管理

mysql-connector-j 8.0版本可以使用的mysql server version包括5.7 8.0

![img](..\img\md-img\2024-08-01-ssm\684a2033f4849a0c9a804f3e0b4534b8.png)

com.mysql.cj.jdbc.Driver 是 mysql-connector-java 6以及以上中的

mysql配置(jdbc8.0)

```properties
jdbc.driver-class-name=com.mysql.cj.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/test?serverTimezone=Asia/Shanghai&useUnicode=true&characterEncoding=utf8&useSSL=false
jdbc.username=root
jdbc.password=root
```

#### 1.配置文件管理数据源对象

druid和c3p0数据源对象交给spring管理

```xml
<bean id="druidDataSource" class="com.alibaba.druid.pool.DruidDataSource">
    <property name="driverClassName" value="com.mysql.cj.jdbc.Driver"/>
    <property name="url" value="jdbc:mysql://localhost:3306/top_news"/>
    <property name="username" value="root"></property>
    <property name="password" value="root"></property>
</bean>

<bean id="c3p0DataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
    <property name="driverClass" value="com.mysql.cj.jdbc.Driver"/>
    <property name="jdbcUrl" value="jdbc:mysql://localhost:3306/top_news"/>
    <property name="user" value="root"/>
    <property name="password" value="root"/>
</bean>
```

maven依赖

```xml
<dependency>
    <groupId>com.mysql</groupId>
    <artifactId>mysql-connector-j</artifactId>
    <version>8.0.33</version>
</dependency>
<dependency>
    <groupId>c3p0</groupId>
    <artifactId>c3p0</artifactId>
    <version>0.9.1.2</version>
</dependency>
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid</artifactId>
    <version>1.1.16</version>
</dependency>
```

#### 2.jdbc.properites文件方式

1.在spring配置文件中开始context命名空间

![image-20240801222616215](..\img\md-img\image-20240801222616215.png)

2.利用context命名空间加载jdbc.properties文件

3.使用属性占位符${}读取properties文件中的属性

```xml
<!--system-properties-mode="NEVER" 不使用系统环境变量,windows系统环境有个username他的优先度高于${username},所以要关掉-->
<context:property-placeholder location="classpath*:jdbc.properties" system-properties-mode="NEVER"/>
```

```xml
<context:property-placeholder location="classpath*:jdbc.properties"/>
<bean id="druidDataSource" class="com.alibaba.druid.pool.DruidDataSource">
    <property name="driverClassName" value="$${driver-class-name}"/>
    <property name="url" value="${url}"/>
    <property name="username" value="${username}"></property>
    <property name="password" value="${password}"></property>
</bean>
```

```java
// 获取环境变量
Map<String, String> getenv = System.getenv();
System.out.println("username = " + getenv.get("USERNAME"));
```



```java
// 路径获取配置文件
ApplicationContext ctx = new ClassPathXmlApplicationContext("classpath:*.xml");
// 绝对路径
// ApplicationContext ctx1 = new FileSystemXmlApplicationContext("C:\\Users\\....\\src\\main\\resources\\applicationContext.xml");
// 获取bean的三种方式
ctx.getBean("bookDao");
BookDao bookDao = ctx.getBean("bookDao", BookDao.class);
BookDao bookDao1 = ctx.getBean(BookDao.class);
bookDao1.add();
```

![1629984980781](C:\Users\32929\Documents\GitHub\zangxin51.github.io\img\md-img\2024-08-01-ssm\1629984980781.png)

BeanFactory创建完毕后,所有bean均为延迟加载, ApplicationContext默认为非懒加载

通过bean标签的lazy-init属性可以配置是否懒加载

```xml
<bean id="bookDao" class="dao.impl.BookDaoImpl" lazy-init="true"/>
```

BeanFactory是所有容器的顶层接口

```java
// 使用BeanFactory
Resource resource = new ClassPathResource("applicationContext.xml");
BeanFactory bf = new XmlBeanFactory(resource);
BookDao bookDao = bf.getBean(BookDao.class);
bookDao.add();
```

### 1.5 容器总结

![1629986510487](C:\Users\32929\Documents\GitHub\zangxin51.github.io\img\md-img\2024-08-01-ssm\1629986510487.png)

![1629986848563](C:\Users\32929\Documents\GitHub\zangxin51.github.io\img\md-img\2024-08-01-ssm\1629986848563.png)

### 1.6 注解开发

#### 1.定义bean

1. 使用@Component注解, 等价的注解还有三个(Controller,Service,Repository)
2. 配置包扫描

```java
@Component("bookDao")
public class BookDaoImpl implements BookDao {}
```

```xml
<context:component-scan base-package="com.xxx.dao"/>
```

#### 2.纯注解开发

利用java类替代了ApplicationContext.xml配置文件 @ComponentScan替代了context:component-scan标签

AnnotationConfigApplicationContext获取容器对象

```java
@Configuration
@ComponentScan({"com.xxx", "com.xxx.dao"})
public class SpringConfig {}
```

```java
ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);
BookDao bookDao = ctx.getBean("bookDao", BookDao.class);
bookDao.add();
```

作用范围和声明周期

```java
@Component("bookDao")
@Scope("singleton") // 作用范围
public class BookDaoImpl implements BookDao {
    @PostConstruct // 生命周期
    public void init() {
        System.out.println("BookDaoImpl.init");
    }
    @PreDestroy // 生命周期
    public void destroy() {
        System.out.println("BookDaoImpl.destroy");
    }
}
```

#### 3.自动装配

**1.引用类型**

```java
@Service
public class BookServiceImpl implements BookService {
    @Autowired
    @Qualifier("bookDao2")
    private BookDao bookDao;
}
```

- 自动装配基于发射创建对象并暴力反射对应属性为私有属性初始化数据, 因此无需提供setter方法
- 必须要有一个无参构造器
- @Qualifier()注解不能单独使用, 要配合@Autowired一起使用

**2.基本类型**

```java
@Repository("bookDao")
@Scope("singleton")
public class BookDaoImpl implements BookDao {
    // 基本类型注入
    @Value("${name}")
    private String name;
}
```

```java
@Configuration
@ComponentScan({"com.xxx", "com.xxx.dao"})
@PropertySource("classpath:jdbc.properties") // 加载外部properties配置文件,这里不允许使用通配符
public class SpringConfig {
}	
```

#### 4.第三方bean管理&第三方依赖管理

1.使用@Bean定义第三方bean

```java
public class JdbcConfig {
    // 1.顶一个方法获取要管理的对象
    @Bean
    public DataSource dataSource() {
        DruidDataSource ds = new DruidDataSource();
        ds.setDriverClassName("com.mysql.cj.jdbc.Driver");
        ds.setUrl("jdbc:mysql://localhost:3306/top_news);
        ds.setUsername("root");
        ds.setPassword("roots");
        return ds;
    }
}
```

2.将独立的 JdbcConfig配置类加入核心配置(使用@Import注解)

```java
@Configuration
@ComponentScan("com.xxx")
@Import(JdbcConfig.class)
public class Config {}
```

3.第三方基本类型(成员变量)和引用类型(方法形参)的注入

```java
public class JdbcConfig {
    // 普通类型
    @Value("${driver-class-name}")
    private String driver;
    @Value("${url}")
    private String url;
    @Value("${username}")
    private String username;
    @Value("${password}")
    private String password;

    // 1.顶一个方法获取要管理的对象
    // 2.BookDao采用的按类型自动装配
    @Bean
    public DataSource dataSource(BookDao bookDao) {
        System.out.println(bookDao);
        DruidDataSource ds = new DruidDataSource();
        ds.setDriverClassName(driver);
        ds.setUrl(url);
        ds.setUsername(username);
        ds.setPassword(password);
        return ds;
    }
}
```

##### 5.注解开发总结

![1630134786448](C:\Users\32929\Documents\GitHub\zangxin51.github.io\img\md-img\2024-08-01-ssm\1630134786448.png)

### 1.7 spring整合mysbatis

整合依赖

```xml
<!--整合mybatis专用包: mybatis-spring spring-jdbc-->
<dependency>
    <groupId>org.mybatis</groupId>
    <artifactId>mybatis-spring</artifactId>
    <version>2.1.1</version>
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-jdbc</artifactId>
    <version>5.3.30</version>
</dependency>
<dependency>
    <groupId>org.mybatis</groupId>
    <artifactId>mybatis</artifactId>
    <version>3.5.6</version>
</dependency>
<dependency>
    <groupId>com.mysql</groupId>
    <artifactId>mysql-connector-j</artifactId>
    <version>8.0.33</version>
</dependency>
<dependency>
    <groupId>com.mysql</groupId>
    <artifactId>mysql-connector-j</artifactId>
    <version>8.0.33</version>
</dependency>
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid</artifactId>
    <version>1.1.16</version>
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>5.3.30</version>
</dependency>
```

mybatis配置类

```java
public class MybatisConfig {
    // 构造sessionFactory, 数据源采用自动装配
    @Bean
    public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource) {
        SqlSessionFactoryBean ssfb = new SqlSessionFactoryBean();
        ssfb.setTypeAliasesPackage("com.xxx.bean");
        ssfb.setDataSource(dataSource);
        return ssfb;
    }
	// mapper扫描
    @Bean
    public MapperScannerConfigurer mapperScannerConfigurer() {
        MapperScannerConfigurer msc = new MapperScannerConfigurer();
        msc.setBasePackage("com.xxx.dao");
        return msc;
    }
}
```

jdbc数据源

```java
public class JdbcConfig {
    // 普通类型
    @Value("${jdbc.driver-class-name}")
    private String driver;
    @Value("${jdbc.url}")
    private String url;
    @Value("${jdbc.username}")
    private String username;
    @Value("${jdbc.password}")
    private String password;

    @Bean
    public DataSource dataSource() {
        DruidDataSource ds = new DruidDataSource();
        ds.setDriverClassName(driver);
        ds.setUrl(url);
        ds.setUsername(username);
        ds.setPassword(password);
        return ds;
    }
}
```

spring核心配置类

```java
@Configuration
@ComponentScan("com.xxx")
@PropertySource("classpath:jdbc.properties")
@Import({JdbcConfig.class, MybatisConfig.class})
public class SpringConfig {}
```

测试

```java
ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);
AccountService accountService = ctx.getBean(AccountService.class);
Account account = accountService.findById(1);
System.out.println("account = " + account);
```

### 1.8 Junit整合

依赖

```xml
<dependency>
    <groupId>junit</groupId>
    <artifactId>junit</artifactId>
    <version>4.12</version>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-test</artifactId>
    <version>5.3.30</version>
</dependency>
```

指定类运行器(@RunWith)和spring配置位置(@ContextConfiguration)

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes = SpringConfig.class)
public class AccountServiceImplTest {
    @Autowired
    private AccountService accountService;
    
    @Test
    public void findById() {
        System.out.println(accountService.findById(1));
    }
    
    @Test
    public void findAll() {
        System.out.println(accountService.findAll());
    }
}	
```

### 1.9 AOP

#### 1.aop基本概念

aspect oriented programming 面向切面编程

作用: 在不改动原始设计的基础上为其进行功能增强

实现: 代理模式

连接点(joinPonit):所有方法,执行过程中任意位置

切入点(pointcut):匹配连接点的式子

范围:切入点是连接点的子集

通知(advice): 在切入点执行的操作,也就是共性操作,或者说增强的功能

切面(Aspect): 描述通知与切入点的对应关系

#### 2.quickstart

目标: 在接口执行时打印系统当前时间

依赖

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>5.3.30</version>
</dependency>
<dependency>
    <groupId>org.aspectj</groupId>
    <artifactId>aspectjweaver</artifactId>
    <version>1.9.7</version>
</dependency>
```

**切面类(@Aspect注解)**

```java
@Aspect  // 切面
@Component 
public class MyAdvice {
    @Pointcut("execution(void com.xxx.dao.BookDao.update())")  // 切入点
    private void pt() {} //  切入点方法 

    @Before("pt()") // 通知
    public void method() {
        System.out.println(System.currentTimeMillis());
    }
}
```

在配置类中**开启aspectj自动代理**

```java
@Configuration
@ComponentScan("com.xxx")
@EnableAspectJAutoProxy
public class SpringConfig {}
```

注意: 切入点方法必须是私有方法,空参,无返回值

#### 3.aop工作流程

1. spring容器启动
2. 读取所有切面配置中的切入点
3. 初始化bean,判断bean对应的类中的方式是否匹配到任意切入点
   - 匹配失败,创建对象
   - 匹配成功,创建原始对象的代理对象
4. 获取bean的执行方法
   - 获取bean, 调用方法执行
   - 获取bean是代理对象时, 根据代理对象的运行模式执行增强的内容(包括原来的内容)

AOP核心概念: 代理模式

- 目标对象
- 代理对象

#### 4.AOP切入点表达式

切入点: 要增强的方法

切入点: 要进行增强的方法的描述方式

切入点表达式: execution (访问控制修饰符 返回值 包名.类/接口名.方法名(参数) 异常名)

```java
execution(void com.xxx.dao.impl.BookDaoImpl.update())
```

通配符: 

\* : 单个独立的任意符号,可以独立出现,也可以作为前缀和后缀的通配符出现

.. : 多个连续的任意符号, 可以独立出现, 常用于简化包名和参数的书写

\+ : 专用与匹配子类

例子:

com.xxx.dao.impl.BookDaoImpl#update()的匹配

```java
@Pointcut("execution(void com.xxx.dao.impl.BookDaoImpl.update())")  // yes
@Pointcut("execution(* com.xxx.dao.impl.BookDaoImpl.update(*))") // no
@Pointcut("execution(void com.*.*.*.*.update())") // yes
@Pointcut("execution(void com.*.*.*.update())") //yes
@Pointcut("execution(* *..*(..))")  //yes 匹配全部方法
@Pointcut("execution(* *..u*(..))")  //yes
@Pointcut("execution(* com.xxx.*.*Service.*(..))") // 匹配所有com.xxx.service层方法
```

书写技巧

- 按照代码规范书写
- 描述切入点通常描述接口, 而不采用实现类
- 访问控制符针对接口开发均采用public描述(可以省略)
- 返回值类型对于增删改类使用精准类型加速匹配, 对查询使用*通配符快速描述
- 包名尽量不用..匹配,效率过低,通常采用*做单个包描述,或精准匹配
- 接口名/类名采用*匹配, 如UserService书写成\*Service
- 方法名书写以动词进行精准匹配,名词采用\*匹配, 如getById书写成getBy*,selectAll写成selectAll
- 参数规则复杂, 根据业务方法灵活调整
- 通常不使用异常作为匹配规则

#### 5.AOP通知类型

```java
// 准备切入点
@Pointcut("execution(void com.xxx.dao.BookDao.update())")
private void pt() {}
```

前置通知

```java
@Before("pt()")
public void before() {
    System.out.println("MyAdvice.before");
}
```

后置通知

```java
@After("pt()")
public void after() {
    System.out.println("MyAdvice.after");
}
```

环绕通知(重点 **ProceedingJoinPoint参数, 调用proceed方法,获取返回值, 必须返回值Object**)

```java
@Around("pt2()")
public Object around(ProceedingJoinPoint pjp) throws Throwable {
    System.out.println("MyAdvice.around before");
    //  表示对原始操作的调用
    Object result = pjp.proceed();
    System.out.println("MyAdvice.around after");
    return result;
}
```

返回后通知, 与after的区别是, 原方法抛出异常后, afterReturning中断, after执行完毕

```java
@AfterReturning("pt2()")
public void afterReturning() {
    System.out.println("MyAdvice.afterReturning");
}
```

异常通知(只有在发生异常时,才调用)

```java
@AfterThrowing("pt2()")
public void afterThrowing() {
    System.out.println("MyAdvice.afterThrowing");
}
```

**Around通知总结**

1. 环绕通知必须依赖形参ProceedingJoinPoint才能实现对原始方法的调用，进而实现原始方法调用前后同时添加通知
2. 通知中如果未使用ProceedingJoinPoint对原始方法进行调用将跳过原始方法的执行
3. 对原始方法的调用可以不接收返回值，通知方法设置成void即可，如果接收返回值，最好设定为Object类型
4. 原始方法的返回值如果是void类型，通知方法的返回值类型可以设置成void,也可以设置成Object
5. 由于无法预知原始方法运行后是否会抛出异常，因此环绕通知方法必须要处理Throwable异常

#### 6.**测量业务层接口执行效率(耗时)**

需求: 任意业务层接口执行事件均可显示其执行效率

分析:

1. 业务功能: 业务层接口执行前后分别记录时间,求差值得到执行效率
2. 通知类型选择前后均可以增强的类型----->**环绕通知**

切面类

```java
@Aspect
@Component
public class ProjectAdvice {
    @Pointcut("execution(* com.xxx.service.*Service.*(..))") // 匹配业务层所有方法
    private void servicePt() {
    }

    @Around("ProjectAdvice.servicePt()")
    public void runSpeed(ProceedingJoinPoint pjp) throws Throwable {
        // 获取方法名和类名
        Signature signature = pjp.getSignature();
        String className = signature.getDeclaringTypeName();
        String methodName = signature.getName();
        long start = System.currentTimeMillis();
        for (int i = 0; i < 10000; i++) {
            pjp.proceed();
        }
        long end = System.currentTimeMillis();
        System.out.println("业务层接口" + className + "." + methodName + "万次执行时间: " + (end - start) + "ms");
    }
}
```

配置类

```java
@Configuration
@ComponentScan("com.xxx")
@PropertySource("classpath:jdbc.properties")
@Import({JdbcConfig.class, MybatisConfig.class})
@EnableAspectJAutoProxy
public class SpringConfig {}
```

测试类

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes = SpringConfig.class)
public class AccountServiceImplTest {
    @Autowired
    private AccountService accountService;

    @Test
    public void findById() {
        accountService.findById(1);
    }

    @Test
    public void findAll() {
        accountService.findAll();
    }
}
// output
// 业务层接口com.xxx.service.AccountService.findAll万次执行时间: 1498ms
// 业务层接口com.xxx.service.AccountService.findById万次执行时间: 1015ms
```

#### 7.AOP获取通知的数据

获取切入点方法的参数

- JoinPoint: 适用于前置,后置,返回后,异常抛出后
- **ProceedingJoinPoint**: 适用于环绕通知

获取切入点方法返回值

- 返回后通知
- 环绕通知

获取切入点方法运行异常信息

- 抛出异常后通知
- 环绕通知

```java
@Pointcut("execution(int com.xxx.dao.BookDao.update(..))")
private void pt2() {
}

@Before("pt2()")
public void before(JoinPoint jp) {
    Object[] args = jp.getArgs();
    System.out.println("before args = " + Arrays.toString(args));
    System.out.println("MyAdvice.before");
}

@After("pt2()")
public void after(JoinPoint jp) {
    Object[] args = jp.getArgs();
    System.out.println("after args = " + Arrays.toString(args));
    System.out.println("MyAdvice.after");
}

@Around("pt2()")
public Object around(ProceedingJoinPoint pjp) throws Throwable {
    Object[] args = pjp.getArgs();
    System.out.println("around args = " + Arrays.toString(args));
    args[0] = 666;
    System.out.println("MyAdvice.around before");
    Object result = pjp.proceed(args);
    System.out.println("MyAdvice.around after ret=" + result);
    return result;
}

@AfterReturning(value = "pt2()", returning = "ret")
public void afterReturning(JoinPoint jp, Object ret) {
    Object[] args = jp.getArgs();
    System.out.println("afterReturning args = " + Arrays.toString(args));
    System.out.println("MyAdvice.afterReturning ret=" + ret);

}

@AfterThrowing(value = "pt2()", throwing = "t")
public void afterThrowing(Throwable t) {
    System.out.println("MyAdvice.afterThrowing: t=" + t);
}
```

#### 8.网盘密码数据兼容案例

需求: 密码输入时去除尾部多余的空格

分析:

1. 在所有业务方法执行之前对所有输入的参数进行格式处理 trim()
2. 使用处理后的参数调用原始方法----环绕通知中存在对原始方法的调用

 配置类

```java
@Configuration
@ComponentScan("com.xxx")
@EnableAspectJAutoProxy
public class SpringConfig {}
```

切面类

```java
@Component
@Aspect
public class DataAdvice {
    @Pointcut("execution(boolean com.xxx.service.ResourceService.openURL(*,*))")
    private void servicePt() {}

    @Around("DataAdvice.servicePt()")
    public Object trimStr(ProceedingJoinPoint pjp) throws Throwable {
        Object[] args = pjp.getArgs();
        // 改参数
        for (int i = 0; i < args.length; i++) {
            // 判断参数是不是字符串
            if (args[i].getClass().equals(String.class)) {
                args[i] = args[i].toString().trim();
            }
        }
        // 将改的参数进去,必须
        Object ret = pjp.proceed(args);
        return ret;
    }
}
```

测试

```java
AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);
ResourceService resourceService = ctx.getBean(ResourceService.class);
boolean isSuccess = resourceService.openURL("http://pan.baidu.com", " root ");
System.out.println("isSuccess = " + isSuccess);
// output
// password.length = 4
// isSuccess = true
```

### 1.10 Spring事务

#### 1.Spring事务概念

事务作用: 在数据库层面保障一系列的数据库操作同时成功/失败

Spring事务作用: 在数据层或业务层保障一系列的数据库操作同时成功/失败

Spring事务接口: 

```java
public interface PlatformTransactionManager extends TransactionManager {
	void commit(TransactionStatus status) throws TransactionException;
	void rollback(TransactionStatus status) throws TransactionException;
}
```

#### 2.案例: 银行账户转账(事务quickstart)

需求:实现任务两个账户间转账操作

需求微缩: A账户减钱, B账户加钱

分析:

1. 数据层: 指定账户减钱outMoney, 指定账户加钱(inMoney)
2. 业务层提供转账操作(transfer), 调用加钱和减钱操作
3. 提供两个账号和操作金额执行转账操作
4. 基于Spring整合Mybatis环境搭建上述操作

结果分析:

1. 程序正常执行时, 账号金额A加B减
2. 程序出现异常时, 转账失败, 但是之前操作成功, 异常之后操作失败, 业务整体失败

使用Spring事务quickstart

1.在业务层上添加Spring事务管理

```java
@Transactional
void transfer(String out, String in, Double money);
```

@Transactional通常加在接口方法上, 而不是实现类上, 降低耦合

注解式事务可以添加业务方法上表示当前方法开启事务, 也可以添加到接口上, 表示当前接口中所有方法开启事务

2.设置事务管理器

```java
// 定义事务管理器, mybatis使用的是jdbc事务管理器
@Bean
public PlatformTransactionManager transactionManager(DataSource dataSource) {
    DataSourceTransactionManager tm = new DataSourceTransactionManager();
    tm.setDataSource(dataSource);
    return tm;
}
```

3.开启注解式事务驱动

```java
@Configuration
@ComponentScan("com.xxx")
@Import({MybatisConfig.class,  JdbcConfig.class})
@PropertySource("classpath:jdbc.properties")
@EnableTransactionManagement // 开启注解事务
public class SpringConfig {}
```

案例代码

dao

```java
public interface AccountDao {
    @Update("update tbl_account set money = money + #{money}  where name = #{name}")
    void inMoney(@Param("name") String name, @Param("money") Double money);

    @Update("update tbl_account set money = money - #{money}  where name = #{name}")
    void outMoney(@Param("name") String name, @Param("money") Double money);
}
```

service

```java
public interface AccountService {
    @Transactional
    void transfer(String out, String in, Double money);
}
```

```java
@Service
public class AccountServiceImpl implements AccountService {
    @Autowired
    private AccountDao accountDao;

    @Override
    public void transfer(String out, String in, Double money) {
        accountDao.outMoney(out, money);
        int i = 1/0;
        accountDao.inMoney(in, money);
    }
}
```

测试类

```java
public class App {
    public static void main(String[] args) {
        ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);
        AccountService accountService = ctx.getBean(AccountService.class);
        accountService.transfer("tom","jerry",100.0);
    }
}
```

bean

```java
public class Account {
    private Integer id;
    private String name;
    private Double money;
}
```

配置类

```java
public class JdbcConfig {
    // 普通类型
    @Value("${jdbc.driver-class-name}")
    private String driver;
    @Value("${jdbc.url}")
    private String url;
    @Value("${jdbc.username}")
    private String username;
    @Value("${jdbc.password}")
    private String password;
    // 定义数据源
    @Bean
    public DataSource dataSource() {
        DruidDataSource ds = new DruidDataSource();
        ds.setDriverClassName(driver);
        ds.setUrl(url);
        ds.setUsername(username);
        ds.setPassword(password);
        return ds;
    }
    // 定义事务管理器
    @Bean
    public PlatformTransactionManager transactionManager(DataSource dataSource) {
        DataSourceTransactionManager tm = new DataSourceTransactionManager();
        tm.setDataSource(dataSource);
        return tm;
    }
}
```

```java
public class MybatisConfig {
    // 构造sessionFactory, 数据源采用自动装配
    @Bean
    public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource) {
        SqlSessionFactoryBean ssfb = new SqlSessionFactoryBean();
        ssfb.setTypeAliasesPackage("com.xxx.bean");
        ssfb.setDataSource(dataSource);
        return ssfb;
    }
    // mapper扫描
    @Bean
    public MapperScannerConfigurer mapperScannerConfigurer() {
        MapperScannerConfigurer msc = new MapperScannerConfigurer();
        msc.setBasePackage("com.xxx.dao");
        return msc;
    }
}
```

```java
@Configuration
@ComponentScan("com.xxx")
@Import({MybatisConfig.class,  JdbcConfig.class})
@PropertySource("classpath:jdbc.properties")
@EnableTransactionManagement // 开启注解事务
public class SpringConfig {}

```

```properties
jdbc.driver-class-name=com.mysql.cj.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/spring_db?serverTimezone=Asia/Shanghai&useUnicode=true&characterEncoding=utf8&useSSL=false
jdbc.username=root
jdbc.password=root
```

```sql
create schema if not exists spring_db collate utf8mb4_unicode_ci;
DROP TABLE IF EXISTS `tbl_account`;
CREATE TABLE `tbl_account` (
  `id` int(11) NOT NULL,
  `name` varchar(35) DEFAULT NULL,
  `money` double DEFAULT NULL,
  PRIMARY KEY (`id`)
);
INSERT INTO `tbl_account` VALUES (1,'tom',900),(2,'jerry',1100);
```

#### 3.spring事务角色

事务管理员: 发起事务方, 在Spring中通常指代业务层开始事务的方法

事务协调员: 加入事务方, 在Spring中通常指代数据层方法, 也可是业务层方法

事务的统一管理必须使用同一个数据源

#### 4.事务配置

![1630250069844](C:\Users\32929\Desktop\cai\backend\ssm\课程笔记\基础框架8笔记\Spring笔记\spring_day03\assets\1630250069844.png)

上面这些属性都可以在`@Transactional`注解的参数上进行设置。

* readOnly：true只读事务，false读写事务，增删改要设为false,查询设为true。

* timeout:设置超时时间单位秒，在多长时间之内事务没有提交成功就自动回滚，-1表示不设置超时时间。

* rollbackFor:当出现指定异常进行事务回滚

* noRollbackFor:当出现指定异常不进行事务回滚

  * 思考:出现异常事务会自动回滚，这个是我们之前就已经知道的

  * noRollbackFor是设定对于指定的异常不回滚，这个好理解

  * rollbackFor是指定回滚异常，对于异常事务不应该都回滚么，为什么还要指定?

    * 这块需要更正一个知识点，并不是所有的异常都会回滚事务，比如下面的代码就不会回滚

```java
public interface AccountService {
    /**
     * 转账操作
     * @param out 传出方
     * @param in 转入方
     * @param money 金额
     */
    //配置当前接口方法具有事务
    public void transfer(String out,String in ,Double money) throws IOException;
}

@Service
public class AccountServiceImpl implements AccountService {

    @Autowired
    private AccountDao accountDao;
	@Transactional
    public void transfer(String out,String in ,Double money) throws IOException{
        accountDao.outMoney(out,money);
        //int i = 1/0; //这个异常事务会回滚
        if(true){
            throw new IOException(); //这个异常事务就不会回滚
        }
        accountDao.inMoney(in,money);
    }

}
```

出现这个问题的原因是，Spring的事务只会对`Error异常`和`RuntimeException异常`及其子类进行事务回滚，其他的异常类型是不会回滚的，对应IOException不符合上述条件所以不回滚
    

* 此时就可以使用rollbackFor属性来设置出现IOException异常不回滚

```java
@Service
public class AccountServiceImpl implements AccountService {

    @Autowired
    private AccountDao accountDao;
	 @Transactional(rollbackFor = {IOException.class})
    public void transfer(String out,String in ,Double money) throws IOException{
        accountDao.outMoney(out,money);
        //int i = 1/0; //这个异常事务会回滚
        if(true){
            throw new IOException(); //这个异常事务就不会回滚
        }
        accountDao.inMoney(in,money);
    }

}
```

* rollbackForClassName等同于rollbackFor,只不过属性为异常的类全名字符串

* noRollbackForClassName等同于noRollbackFor，只不过属性为异常的类全名字符串

* isolation设置事务的隔离级别

  * DEFAULT   :默认隔离级别, 会采用数据库的隔离级别
  * READ_UNCOMMITTED : 读未提交
  * READ_COMMITTED : 读已提交
  * REPEATABLE_READ : 重复读取
  * SERIALIZABLE: 串行化

介绍完上述属性后，还有最后一个事务的传播行为，为了讲解该属性的设置，我们需要完成下面的案例。

#### 5.案例: 转账业务追加日志

需求: 实现任意两个账户之间转账操作, 并对每次转账操作在数据库进行留痕

需求微缩: A账户减钱, B账户价钱, 数据库要记录日志

分析:

1. 基于转账操作案例添加日志模块,实现数据库中记录日志
2. 业务层转账操作(transfer), 调用减钱, 价钱与记录日志功能

预期效果:

无论转账是否成功, 均进行转账日志留痕

新增表 tbl_log

```sql
create table if not exists spring_db.tbl_log
(
    info        varchar(100) null comment '日志信息',
    create_date datetime     null comment '创建时间',
    id          int auto_increment
        primary key
)
    comment '转账日记记录表' collate = utf8mb4_unicode_ci;
```

在logService和AccountService都加上@Transactional注解后, 发现失败后tbl_log日志和tbl_account的金额都会滚

这样就不满足要求: 无论转账是否成功, 均进行转账日志留痕, 要实现该功能需要事务传播性功能: 

propagation = Propagation.*REQUIRES_NEW*

```java
public interface LogService {
    @Transactional
    void log(String out, String in, Double money);
}
```

```java
public interface AccountService {
    @Transactional
    void transfer(String out, String in, Double money);
}
```

```java
@Service
public class AccountServiceImpl implements AccountService {
    @Autowired
    private AccountDao accountDao;
    @Autowired
    private LogService logService;
    @Override
    public void transfer(String out, String in, Double money) {
        try {
            accountDao.outMoney(out, money);
            int i = 1/0;
            accountDao.inMoney(in, money);
        } catch (Exception e) {
            // 这里异常必须抛出去,否则事务不生效
            throw new RuntimeException(e);
        } finally {
            logService.log(out, in, money);
        }
    }
}

```

![1630254257628](C:\Users\32929\Documents\GitHub\zangxin51.github.io\img\md-img\2024-08-01-ssm\1630254257628.png)

## 2. SpringMVC

### 2.1概述

springmvc <---> 和servlet等价, 都是表现层技术

表现层: springmvc/servlet

业务层:..

dao层: jdbc/mybatis/hibernate

springmvc是一种表现层框架技术

springmvc用于进行表现层功能开发

### 2.2 springmvc quickstart(注意依赖版本号)

**1.依赖 jdk1.8 + tomcat8(本地tomcat) tomcat10跑不起来, spring依赖使用5.3.0以下的**

```xml
    <dependencies>
        <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>javax.servlet-api</artifactId>
            <version>3.1.0</version>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-webmvc</artifactId>
            <version>5.2.10.RELEASE</version>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
            <version>5.2.10.RELEASE</version>
            <scope>compile</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.tomcat.maven</groupId>
                <artifactId>tomcat7-maven-plugin</artifactId>
                <version>2.1</version>
                <configuration>
                    <port>80</port>
                    <path>/</path>
                </configuration>
            </plugin>
        </plugins>
    </build>
```

2.创建springMVC控制器(等同于Servlet)

```java
@Controller
public class UserController {
    @RequestMapping("/save")
    @ResponseBody
    public String save() {
        System.out.println("user save");
        return "{'module':'springmvc'}";
    }
}
```

3.spring配置类

```java
@Configuration
@ComponentScan("com.xxx.controller")
public class SpringMvcConfig {}
```

4.初始化Servlet容器, 加在springMVC环境, 并设置MVC技术处理的请求

定义一个servlet容器启动的配置类, 在里面加在spring的配置(有了这个就可以删除web.xml文件)

```java
public class ServletContainerInitConfig extends AbstractDispatcherServletInitializer {
    // 加载springmvc容器
    @Override
    protected WebApplicationContext createServletApplicationContext() {
        AnnotationConfigWebApplicationContext ctx = new AnnotationConfigWebApplicationContext();
        ctx.register(SpringMvcConfig.class);
        return ctx;
    }
    // 设置哪些请求归属springmvc处理
    @Override
    protected String[] getServletMappings() {
        return new String[]{"/"};
    }
    // 加载spring容器配置
    @Override
    protected WebApplicationContext createRootApplicationContext() {
        return null;
    }
}
```

入门案例工作流程分析

启动服务的过程

1. 服务启动, 执行ServletContainerInitConfig类型, 初始web化容器
2. 执行createServletApplicationContext()方法, 创建WebApplicationContext对象
3. 加载SpringMVCConfig配置类型(包扫描)
4. 执行ComponentScan加载对应的bean
5. 加载UserController, 每个@RequestMapping的名称对应一个具体方法
6. 执行getServletMappings方法，设定SpringMVC拦截请求的路径规则

单次请求过程

1. 发送请求`http://localhost/save`
2. web容器发现该请求满足SpringMVC拦截规则，将请求交给SpringMVC处理
3. 解析请求路径/save
4. 由/save匹配执行对应的方法save(）
   * 上面的第五步已经将请求路径和方法建立了对应关系，通过/save就能找到对应的save方法
5. 执行save()
6. 检测到有@ResponseBody直接将save()方法的返回值作为响应体返回给请求方



### 2.3 bean加载与控制(分容器加载)

SpringMVC相关bean (表现层bean)

Spring控制的bean

- 业务bean (Service)
- 功能bean (DataSource等)

因功能不同, 如何避免Spring错误加载到SpringMVC的bean--加载Spring控制的bean的时候排除掉SpringMVC控制的bean

spring包扫描dao和service

方式一: 精确扫描Service和dao

方式二: 扫描所有包,排除controller

```java
@Configuration
//@ComponentScan({"com.xxx.service", "com.xxx.dao"})
@ComponentScan(value = "com.xxx",
        excludeFilters = @ComponentScan.Filter(
                type = FilterType.ANNOTATION,
                classes = Controller.class
        )
)
@PropertySource("classpath:jdbc.properties")
@Import({JdbcConfig.class, MybatisConfig.class})
public class SpringConfig {}

```

SpringMVC扫描controller

```java
@Configuration
@ComponentScan("com.xxx.controller")
public class SpringMvcConfig {}
```

注册Spring和SpringMVC到web容器中

```java
public class ServletContainersInitConfig1 extends AbstractAnnotationConfigDispatcherServletInitializer {
    @Override
    protected Class<?>[] getRootConfigClasses() {
        return new Class[]{SpringConfig.class};
    }
    @Override
    protected Class<?>[] getServletConfigClasses() {
        return new Class[]{SpringMvcConfig.class};
    }
    @Override
    protected String[] getServletMappings() {
        return new String[]{"/"};
    }
}
```

### 知识点1：@ComponentScan

| 名称     | @ComponentScan                                               |
| -------- | ------------------------------------------------------------ |
| 类型     | 类注解                                                       |
| 位置     | 类定义上方                                                   |
| 作用     | 设置spring配置类扫描路径，用于加载使用注解格式定义的bean     |
| 相关属性 | excludeFilters:排除扫描路径中加载的bean,需要指定类别(type)和具体项(classes)<br/>includeFilters:加载指定的bean，需要指定类别(type)和具体项(classes) |

### 2.4请求

#### 2.4.1请求路径

```java
@Controller
@RequestMapping("/book")
public class BookController {
    @RequestMapping("/save")
    @ResponseBody
    public String save() {
        System.out.println("book save ...");
        return "{'info':'success}";
    }
}	
```

#### 2.4.2 请求方式



```java
@Controller
@RequestMapping("/user")
public class UserController {
    @RequestMapping("/save")
    @ResponseBody
    public String save(String name, Integer age) {
        System.out.println("user save ... name=" + name);
        return "{'info':'success,'name':" + name + ",age=" + age + "}";
    }
}
```

GET传参

普通参数:url地址传参, 地址参数名与形参变量名相同,定义形参即可接收参数

```
http://localhost/user/save?name=zhangsan&age=23
```

![image-20240803102848840](C:\Users\32929\Documents\GitHub\zangxin51.github.io\img\md-img\image-20240803102848840.png)

POST请求传参

```
http://localhost/user/save
```

![image-20240803103002813](C:\Users\32929\Documents\GitHub\zangxin51.github.io\img\md-img\image-20240803103002813.png)

#### 2.4.3请求乱码问题

get请求: **请求行**编码格式与tomcat的请求行解码方式不一致就会导致, 解决方法: 将tomcat uriencoding修改为utf-8

post请求: **请求体**乱码, 修改后端默认解码字符集: request.setCharacterEncoding("UTF-8"), 这一行代码的意思是设置解析请求体使用的字符集

```java
// Springmvc解决请求体乱码问题, 设置一个过滤器
public class ServletContainerInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer {
    // 处理post请求乱码
    @Override
    protected Filter[] getServletFilters() {
        CharacterEncodingFilter filter = new CharacterEncodingFilter("UTF-8", true);
        return new Filter[]{filter};
    }
    // 略去其他三个方法
}
```

响应乱码问题: 浏览器在接收响应信息时,使用了不同的字符集或者是不支持中文的字符集就会出现乱码

response.setContentType("text/html;charset=utf-8"), 设置响应头ContentType: text/html;charset=utf-8, 告知浏览器用该方式解析响应

Springmvc默认的ContentType字符集为iso-8859-1

```java
// org.springframework.http.converter.StringHttpMessageConverter
static {
        DEFAULT_CHARSET = StandardCharsets.ISO_8859_1;
}
```



```java
// 将默认的iso-iso-8859-1修改为UTF-8
@Configuration
@ComponentScan("com.xxx.controller")
@EnableWebMvc
public class SpringMvcConfig implements WebMvcConfigurer {
    //    通过@EnableWebMVC配置的时候起作用，
    @Override
    public void extendMessageConverters(List<HttpMessageConverter<?>> converters) {
        for (HttpMessageConverter<?> httpMessageConverter : converters) {
            if (StringHttpMessageConverter.class.isAssignableFrom(httpMessageConverter.getClass())) {
                ((StringHttpMessageConverter) httpMessageConverter).setDefaultCharset(Charset.forName("UTF-8"));
            }
        }
    }
}
```

#### 2.4.4 5种参数传递方式

1.形参和请求参数一样

```java
// http://localhost/user/save?name=张三&age=23
public String save(String name, Integer age) {
```

2.形参和请求参数不一致(@RequestParam注解)

```http
http://localhost/user/save?name=张三&age=23	
```

```java
 public String save(@RequestParam("name") String username, Integer age) {
```

3.实体类形参接收请求参数

```http
POST http://localhost/user/save1
name:张三
age:33
```

```java
@RequestMapping("/save1")
@ResponseBody
public String save1(User user) {
    System.out.println("user save ... username=" + user);
    return "{'info':'success,'user':" + user + "}";
}	
```

```java
public class User {
    private String name;
    private String age;
} // setter方法必须	
```

4.嵌套实体对象接收请求参数

```http
http://localhost/user/save2?name=张三&age=23&address.province=广东&address.city=深圳
```

```java
@RequestMapping("/save2")
@ResponseBody
public String save2(User user) {}
```

```java
public class User {
    private String name;
    private String age;
	// 地址实体类
    private Address address;
    // setter方法和address的getter方法必须
}
```

```java
public class Address {
    private String province;
    private String city;
}
```

5.数组参数

```http
http://localhost/user/save3?hobby=唱&hobby=跳&hobby=篮球	
```

```java
    public String save3(String hobby[]) {}
```

6.集合参数

传参与数组没有区别, 就是需要在形参前加@RequestParam

```http
http://localhost/user/save4?hobby=唱&hobby=跳&hobby=篮球 
```

```java
public String save4(@RequestParam List<String> hobby) {
```

#### 2.4.5 json参数传递 (@RequestBody)



```http

```

```java
@Configuration
@ComponentScan("com.xxx.controller")
@EnableWebMvc // 开启webmvc注解
public class SpringMvcConfig implements WebMvcConfigurer {}
```

1.集合参数传递

http://localhost/user/save5
body: ["sing","dance","rap","basketball","6666"]

```java
@RequestMapping("/save5")
@ResponseBody
public String save5(@RequestBody List<String> hobby) {}
```

2.对象参数传递

```http
http://localhost/user/save6
{
    "name":"张三",
    "age":22,
    "address":{
        "privince":"广东",
        "city":"深圳"
    }
}
```

```
@RequestMapping("/save6")
@ResponseBody
public String save6(@RequestBody User user) {}
```

3.对象集合参数传递

```http
http://localhost/user/save7
[
    {
    "name":"张三",
    "age":22,
    "address":{
        "privince":"广东",
        "city":"深圳"
    }
},
{
    "name":"李四",
    "age":34,
    "address":{
        "privince":"北京",
        "city":"北京"
    }
}
]
```

```java
@RequestMapping("/save7")
@ResponseBody
public String save7(@RequestBody List<User> user) {}
```

总结:

@RequestParam与@RequestBody的区别

@RequestParam用于接收url地址传参,和表单传参 application/x-www-form-urlencoded

@RequestBody用于接收json数据[application/json]

#### 2.4.6日期类型参数传递(@DateTimeFormat注解使用)

```http
http://localhost/book/dateParam?date=2022-1-1&date2=2022/1/1&date3=2022/1/1 08:30:30
```

```java
@RequestMapping("/dateParam")
@ResponseBody
public String dateParam(@DateTimeFormat(pattern = "yyyy-MM-dd") Date date,
                        @DateTimeFormat(pattern = "yyyy/MM/dd") Date date2,
                        @DateTimeFormat(pattern = "yyyy/MM/dd HH:mm:ss") Date date3) {
    System.out.println("dateParam yyyy-MM-dd ..." + date);
    System.out.println("dateParam yyyy/MM/dd ..." + date2);
    System.out.println("dateParam yyyy/MM/dd HH:mm:ss ..." + date3);
    return "{'info':'success,date:" + date + "}";
}
```

#### 2.4.7类型转换器

```java
@FunctionalInterface
public interface Converter<S, T> {
	@Nullable
	T convert(S source);

}
```

请求参数年龄数据: String-->Integer

日期格式转换: String --> Date

@EnableWebMvc注解功能之一: 根据类型匹配对应的类型转换器

### 2.5响应

#### 2.5.1四种响应方式

响应页面

响应数据

- 文本数据
- json数据

```java
@Controller
public class UserController {
    // 响应页面/跳转页面
    @RequestMapping("/toPage")
    public String toPage() {
        System.out.println("跳转页面");
        return "page.jsp";
    }
    // 响应纯文本数据
    @RequestMapping("/toText")
    @ResponseBody
    public String toText() {
        System.out.println("返回纯文本数据");
        return "reponse text";
    }
    // 响应pojo对象
    @RequestMapping("/toJsonPojo")
    @ResponseBody
    public User toJsonPOJO() {
        System.out.println("返回json对象数据");
        User user = new User();
        user.setName("张三");
        user.setAge(22);
        return user;
    }
    // 响应pojo对象集合
    @RequestMapping("/toJsonPojoList")
    @ResponseBody
    public List<User> toJsonPOJOList() {
        List<User> userList = new ArrayList<>();
        System.out.println("返回json对象数据集合");
        for (int i = 0; i < 3; i++) {
            User user = new User();
            user.setName("张三" + i);
            user.setAge(10 * i);
            userList.add(user);
        }
        return userList;
    }
}
```

#### 2.5.2 @ResponseBody注解  响应json数据

- 方法注解: 位置SpringMVC控制器方法上面 

- 作用: 设置当前控制器返回值作为响应体

public interface HttpMessageConverter\<T> {} 接口定义了将对象转为json数据

```java
public interface HttpMessageConverter<T> {
    boolean canRead(Class<?> var1, @Nullable MediaType var2);

    boolean canWrite(Class<?> var1, @Nullable MediaType var2);

    List<MediaType> getSupportedMediaTypes();

    T read(Class<? extends T> var1, HttpInputMessage var2) throws IOException, HttpMessageNotReadableException;

    void write(T var1, @Nullable MediaType var2, HttpOutputMessage var3) throws IOException, HttpMessageNotWritableException;
}		
```

### 2.6 REST风格

#### 2.6.1 简介

REST: Representational State Transfer, 表现形式状态转换

传统风格资源描述形式

```http
http://localhost/user/getById?id=1
http://localhost/user/saveUser
```

REST风格资源描述形式

```http
http://localhost/user/1
http://localhost/user/
```

优点

- 隐藏资源的访问行为, 无法通过地址得知对资源是什么操作
- 书写简化

按照REST风格访问资源时使用==行为动作==区分对资源进行了何种操作

* `http://localhost/users`	查询全部用户信息 GET（查询）
* `http://localhost/users/1`  查询指定用户信息 GET（查询）
* `http://localhost/users`    添加用户信息    POST（新增/保存）
* `http://localhost/users`    修改用户信息    PUT（修改/更新）
* `http://localhost/users/1`  删除用户信息    DELETE（删除）

通过路径+请求方式=确定访问行为(增/删/改/查)

描述模块的名称通常使用复数，也就是加s的格式描述，表示此类资源，而非单个资源，例如:users、books、accounts......

根据REST风格对资源进行访问称为==RESTful==。

#### 2.6.2 RESTful quickstart

依赖
```xml
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
    <version>2.13.5</version>
</dependency>
<dependency>
    <groupId>javax.servlet</groupId>
    <artifactId>javax.servlet-api</artifactId>
    <version>3.1.0</version>
    <scope>provided</scope>
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-webmvc</artifactId>
    <version>5.2.10.RELEASE</version>
</dependency>
```

controller

```java
@Controller
public class UserController {
    @RequestMapping(value = "/users", method = RequestMethod.POST)
    @ResponseBody
    public String save() {
        System.out.println("user save ... ");
        return "{'module':'user save'}";
    }

    @RequestMapping(value = "/users/{id}", method = RequestMethod.DELETE)
    @ResponseBody
    public String delete(@PathVariable Integer id) {
        System.out.println("user delete ... " + id);
        return "{'module':'user delete'}";
    }

    @RequestMapping(value = "/users", method = RequestMethod.PUT)
    @ResponseBody
    public String update(@RequestBody User user) {
        System.out.println("user update ... " + user);
        return "{'module':'user update'}";
    }

    @RequestMapping(value = "/users/{id}", method = RequestMethod.GET)
    @ResponseBody
    public String getById(@PathVariable Integer id) {
        System.out.println("user getById ... " + id);
        return "{'module':'user getById'}";
    }

    @RequestMapping(value = "/users/", method = RequestMethod.GET)
    @ResponseBody
    public String getAll() {
        System.out.println("user getAll ... ");
        return "{'module':'user getAll'}";
    }
}
```

@PathVariable注解

- 类型: 形参注解
- 位置: SpringMVC控制器方法形参定义面前
- 作用: 绑定路径参数与处理器方法形参之间的关系, 要求路径参数名与形参名一一对应

三个注解`@RequestBody`、`@RequestParam`、`@PathVariable`,这三个注解之间的区别和应用分别是什么?

* 区别
  * @RequestParam用于接收url地址传参或表单传参
  * @RequestBody用于接收json数据
  * @PathVariable用于接收路径参数，使用{参数名称}描述路径参数
* 应用
  * 后期开发中，发送请求参数超过1个时，以json格式为主，@RequestBody应用较广
  * 如果发送非json格式数据，选用@RequestParam接收请求参数
  * 采用RESTful进行开发，当参数数量较少时，例如1个，可以采用@PathVariable接收请求路径变量，通常用于传递id值

#### 2.6.3简化版本RESTful风格

利用@RestController, @GetMapping, @PostMapping等注解

```java
@RestController
@RequestMapping("/books")
public class BookController {
    @PostMapping
    public String save(@RequestBody Book book) {
        System.out.println("book save ... book=" + book);
        return "{'module':'book save'}";
    }

    @DeleteMapping("/{id}")
    public String delete(@PathVariable Integer id) {
        System.out.println("book delete ... " + id);
        return "{'module':'book delete'}";
    }

    @PutMapping
    public String update(@RequestBody Book book) {
        System.out.println("book update ... " + book);
        return "{'module':'book update'}";
    }

    @GetMapping("/{id}")
    public String getById(@PathVariable Integer id) {
        System.out.println("book getById ... " + id);
        return "{'module':'book getById'}";
    }

    @GetMapping
    public String getAll() {
        System.out.println("book getAll ... ");
        return "{'module':'book getAll'}";
    }
}	
```

#### 2.6.4 基于RESTFul的案例(完整配置版)

图书的增删改查(只有Controller和视图层)

![image-20240803223459454](C:\Users\32929\Documents\GitHub\zangxin51.github.io\img\md-img\image-20240803223459454.png)

maven依赖

```xml
<properties>
    <maven.compiler.source>1.8</maven.compiler.source>
    <maven.compiler.target>1.8</maven.compiler.target>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <!--这里必须打成war,否则部署不上-->
    <packaging>war</packaging>
</properties>
<dependencies>
    <dependency>
        <groupId>com.fasterxml.jackson.core</groupId>
        <artifactId>jackson-databind</artifactId>
        <version>2.13.5</version>
    </dependency>
    <dependency>
        <groupId>javax.servlet</groupId>
        <artifactId>javax.servlet-api</artifactId>
        <version>3.1.0</version>
        <scope>provided</scope>
    </dependency>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-webmvc</artifactId>
        <version>5.2.10.RELEASE</version>
    </dependency>
</dependencies>
```

SpringMVC配置类

```java
@Configuration
@ComponentScan("com.xxx.controller")
@EnableWebMvc
public class SpringMvcConfig implements WebMvcConfigurer {
    // 处理response乱码问题
    @Override
    public void extendMessageConverters(List<HttpMessageConverter<?>> converters) {
        for (HttpMessageConverter<?> converter : converters) {
            if (StringHttpMessageConverter.class.isAssignableFrom(converter.getClass())) {
                ((StringHttpMessageConverter) converter).setDefaultCharset(Charset.forName("UTF-8"));
            }
        }
    }
    // 处理静态资源
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        // 当访问uri匹配到/pages/**的时候,走/pages目录下的内容
        registry.addResourceHandler("/pages/**").addResourceLocations("/pages/");
        registry.addResourceHandler("/css/**").addResourceLocations("/css/");
        registry.addResourceHandler("/js/**").addResourceLocations("/js/");
        registry.addResourceHandler("/plugins/**").addResourceLocations("/plugins/");
    }
}
```

Web容器初始化配置

```java
public class ServletContainerInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer {
    @Override
    protected Class<?>[] getRootConfigClasses() {
        return null;
    }
    @Override
    protected Class<?>[] getServletConfigClasses() {
        return new Class[]{SpringMvcConfig.class};
    }
    @Override
    protected String[] getServletMappings() {
        return new String[]{"/"};
    }
    @Override
    protected Filter[] getServletFilters() {
        CharacterEncodingFilter filter = new CharacterEncodingFilter("UTF-8", true);
        return new Filter[]{filter};
    }
}
```

domain实体类

```java
public class Book {
    private Integer id;
    private String type;
    private String name;
    private String description;
    // getter setter...
} 
```

controller

```java
@RestController
@RequestMapping("/books")
public class BookController {
    private static final List<Book> BOOK_LIST = new ArrayList<>();

    static {
        Book book1 = new Book(1, "轻小说", "刀剑神域", "sword artist");
        Book book2 = new Book(2, "数学", "偏微分方程", "PDE, 姜萍同款");
        Collections.addAll(BOOK_LIST, book1, book2);
    }

    @GetMapping("/{id}")
    public Book getById(@PathVariable Integer id) {
        return BOOK_LIST.get(id);
    }

    @PostMapping
    public String save(@RequestBody Book book) {
        book.setId(BOOK_LIST.size());
        BOOK_LIST.add(book);
        System.out.println("BookController.save");
        return "{'msg':'book save success'}";
    }

    @DeleteMapping("/{id}")
    public String delete(@PathVariable Integer id) {
        System.out.println("BookController.delete");
        boolean isSuccess = (BOOK_LIST.remove(id.intValue()) != null);
        return "{'msg':'book delete success id='" + id + ", isSuccess:" + isSuccess + "}";
    }

    @GetMapping()
    public List<Book> getAll() {
        return BOOK_LIST;
    }
}
```

前端html(css/js/plugins略,到时候代码上传到github去)

这里用的技术是vue2+elementUI

```html
<!DOCTYPE html>

<html>
<head>
    <!-- 页面meta -->
    <meta charset="utf-8">
    <title>SpringMVC案例</title>
    <!-- 引入样式 -->
    <link rel="stylesheet" href="../plugins/elementui/index.css">
    <link rel="stylesheet" href="../plugins/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="../css/style.css">
</head>

<body class="hold-transition">
    <div id="app">
        <div class="content-header">
            <h1>图书管理</h1>
        </div>

        <div class="app-container">
            <div class="box">
                <div class="filter-container">
                    <el-input placeholder="图书名称" v-model="searchBookId" style="width: 200px;"
                              class="filter-item"></el-input>
                    <el-button type="primary" class="butT" @click="getById()">查询</el-button>
                    <el-button type="primary" class="butT" @click="openSave()">新建</el-button>
                </div>

                <el-table size="small" current-row-key="id" :data="dataList" stripe highlight-current-row>
                    <el-table-column type="index" align="center" label="序号"></el-table-column>
                    <el-table-column prop="type" label="图书类别" align="center"></el-table-column>
                    <el-table-column prop="name" label="图书名称" align="center"></el-table-column>
                    <el-table-column prop="description" label="描述" align="center"></el-table-column>
                    <el-table-column label="操作" align="center">
                        <template slot-scope="scope">
                            <el-button type="primary" size="mini">编辑</el-button>
                            <el-button size="mini" type="danger" @click="removeById(scope.$index)">删除</el-button>
                        </template>
                    </el-table-column>
                </el-table>
                <div class="pagination-container">
                    <el-pagination
                            class="pagiantion"
                            @current-change="handleCurrentChange"
                            :current-page="pagination.currentPage"
                            :page-size="pagination.pageSize"
                            layout="total, prev, pager, next, jumper"
                            :total="pagination.total">
                    </el-pagination>
                </div>
                <!-- 新增标签弹层 -->
                <div class="add-form">
                    <el-dialog title="新增图书" :visible.sync="dialogFormVisible">
                        <el-form ref="dataAddForm" :model="formData" :rules="rules" label-position="right"
                                 label-width="100px">
                            <el-row>
                                <el-col :span="12">
                                    <el-form-item label="图书类别" prop="type">
                                        <el-input v-model="formData.type"/>
                                    </el-form-item>
                                </el-col>
                                <el-col :span="12">
                                    <el-form-item label="图书名称" prop="name">
                                        <el-input v-model="formData.name"/>
                                    </el-form-item>
                                </el-col>
                            </el-row>
                            <el-row>
                                <el-col :span="24">
                                    <el-form-item label="描述">
                                        <el-input v-model="formData.description" type="textarea"></el-input>
                                    </el-form-item>
                                </el-col>
                            </el-row>
                        </el-form>
                        <div slot="footer" class="dialog-footer">
                            <el-button @click="dialogFormVisible = false">取消</el-button>
                            <el-button type="primary" @click="saveBook()">确定</el-button>
                        </div>
                    </el-dialog>
                </div>

            </div>
        </div>
    </div>
</body>
<!-- 引入组件库 -->
<script src="../js/vue.js"></script>
<script src="../plugins/elementui/index.js"></script>
<script type="text/javascript" src="../js/jquery.min.js"></script>
<script src="../js/axios-0.18.0.js"></script>
<script>
    var vue = new Vue({
        el: '#app',
        data: {
            searchBookId: null,
            dataList: [],//当前页要展示的分页列表数据
            formData: {},//表单数据
            dialogFormVisible: false,//增加表单是否可见
            dialogFormVisible4Edit: false,//编辑表单是否可见
            pagination: {},//分页模型数据，暂时弃用
        },
        mounted() {
            this.getById()
        },
        methods: {
            // 重置表单
            resetForm() {
                //清空输入框
                this.formData = {};
            },
            // 弹出添加窗口
            openSave() {
                this.dialogFormVisible = true;
                this.resetForm();
            },
            //添加
            saveBook() {
                axios.post("/books", this.formData).then((res) => {
                    this.dialogFormVisible = false
                    window.location.reload(true)
                });
            },
            removeById(index) {
                let isDel = confirm("是否删除")
                if (isDel) {
                    axios.delete("/books/" + index).then((res) => {
                        if (res.status == 200){
                            alert("删除成功")
                            window.location.reload(true)
                        }
                    });
                }
            },
            // getById 或getAll, 根据bookId是否有值
            getById() {
                let url = this.searchBookId == null ? '' : this.searchBookId;
                axios.get("/books/" + url).then((res) => {
                    if (this.searchBookId) {
                        console.log(res)
                        this.dataList = [res.data];
                    } else {
                        this.dataList = res.data
                    }
                });
            }
        }
    })
</script>
</html>
```

### 2.7 SSM整合

1.创建工程

2.SSM整合

- spring
  - springConfig
- mybatis
  - MybatisConfig
  - JdbcConfig
  - jdbc.properties
- SpringMVC
  - ServletConfig
  - SpringMvcConfig

3.功能模块

- 表与实体类
- dao (接口+自动代理)
- servic(接口+实现类)
  - 业务层接口测试(Junit)
- Controller
  - 表现层接口测试(postman)

#### 2.7.1maven依赖

```xml
<packaging>war</packaging>
<dependencies>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-jdbc</artifactId>
        <version>5.2.10.RELEASE</version>
    </dependency>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-webmvc</artifactId>
        <version>5.2.10.RELEASE</version>
    </dependency>
    <dependency>
        <groupId>org.mybatis</groupId>
        <artifactId>mybatis-spring</artifactId>
        <version>2.1.1</version>
    </dependency>
    <dependency>
        <groupId>org.mybatis</groupId>
        <artifactId>mybatis</artifactId>
        <version>3.5.6</version>
    </dependency>
    <dependency>
        <groupId>com.fasterxml.jackson.core</groupId>
        <artifactId>jackson-databind</artifactId>
        <version>2.13.5</version>
    </dependency>
    <dependency>
        <groupId>javax.servlet</groupId>
        <artifactId>javax.servlet-api</artifactId>
        <version>3.1.0</version>
    </dependency>
    <dependency>
        <groupId>com.alibaba</groupId>
        <artifactId>druid</artifactId>
        <version>1.2.6</version>
    </dependency>
    <dependency>
        <groupId>com.mysql</groupId>
        <artifactId>mysql-connector-j</artifactId>
        <version>8.0.33</version>
    </dependency>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-test</artifactId>
        <version>5.2.10.RELEASE</version>
    </dependency>
    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <version>4.12</version>
        <scope>test</scope>
    </dependency>
</dependencies>
```

#### 2.7.2配置类

Spring配置

```java
@Configuration
@ComponentScan({"com.xxx.service"})
@PropertySource("classpath:jdbc.properties")
@Import({JdbcConfig.class, MybatisConfig.class})
@EnableTransactionManagement // 开启注解事务
public class SpringConfig {
}
```

```java
public class JdbcConfig {
    @Value("${jdbc.driver-class-name}")
    private String driver;
    @Value("${jdbc.url}")
    private String url;
    @Value("${jdbc.username}")
    private String username;
    @Value("${jdbc.password}")
    private String password;

    @Bean
    public DataSource dataSource() {
        DruidDataSource dataSource = new DruidDataSource();
        dataSource.setDriverClassName(driver);
        dataSource.setUrl(url);
        dataSource.setUsername(username);
        dataSource.setPassword(password);
        return dataSource;
    }

    // jdbc事务管理器
    @Bean
    public PlatformTransactionManager transactionManager(DataSource dataSource) {
        DataSourceTransactionManager tm = new DataSourceTransactionManager();
        tm.setDataSource(dataSource);
        return tm;
    }
}
```

```java
public class MybatisConfig {
    @Bean
    public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource) {
        SqlSessionFactoryBean ssfb = new SqlSessionFactoryBean();
        ssfb.setDataSource(dataSource);
        ssfb.setTypeAliasesPackage("com.xxx.domain");
        return ssfb;
    }

    @Bean
    public MapperScannerConfigurer mapperScannerConfigurer() {
        MapperScannerConfigurer msc = new MapperScannerConfigurer();
        msc.setBasePackage("com.xxx.dao");
        return msc;
    }
}
```

springmvc配置

```java
public class ServletConfig extends AbstractAnnotationConfigDispatcherServletInitializer {
    @Override
    protected Class<?>[] getRootConfigClasses() {
        return new Class[]{SpringConfig.class};
    }

    @Override
    protected Class<?>[] getServletConfigClasses() {
        return new Class[]{SpringMvcConfig.class};
    }

    @Override
    protected String[] getServletMappings() {
        return new String[]{"/"};
    }

    @Override
    protected Filter[] getServletFilters() { // 过滤器,用utf-8解析请求参数
        CharacterEncodingFilter filter = new CharacterEncodingFilter("UTF-8", true);
        return new Filter[]{filter};
    }
}
```

```java
@Configuration
@ComponentScan("com.xxx.controller")
@EnableWebMvc
public class SpringMvcConfig implements WebMvcConfigurer {
    // 设置响应头ContentType: text/html;charset=utf-8, 告知浏览器用该方式解析响应
    @Override
    public void extendMessageConverters(List<HttpMessageConverter<?>> converters) {
        for (HttpMessageConverter<?> converter : converters) {
            if (StringHttpMessageConverter.class.isAssignableFrom(converter.getClass())) {
                ((StringHttpMessageConverter) converter).setDefaultCharset(Charset.forName("UTF-8"));
            }
        }
    }

    // 处理静态资源
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        // 请求匹配/pages/**时转发到/pages目录下
        registry.addResourceHandler("/pages/**").addResourceLocations("/pages/");
        registry.addResourceHandler("/css/**").addResourceLocations("/css/");
        registry.addResourceHandler("/js/**").addResourceLocations("/js/");
        registry.addResourceHandler("/plugins/**").addResourceLocations("/plugins/");
    }
```

#### 2.7.3表与实体类

```sql
DROP TABLE IF EXISTS `tbl_book`;
CREATE TABLE `tbl_book`
(
    `id`          int(11) NOT NULL AUTO_INCREMENT,
    `type`        varchar(20)  DEFAULT NULL,
    `name`        varchar(50)  DEFAULT NULL,
    `description` varchar(255) DEFAULT NULL,
    PRIMARY KEY (`id`)
);
INSERT INTO `tbl_book`
VALUES (1, '文学', '老人与海', '海明威代表作, 一个人可以被消灭,但是不能被打败-修改test'),
       (2, '文学', '月亮与六便士', '艺术之于生命'),
       (3, '哲学', '斐多篇', '苏格拉底论灵魂不朽'),
       (4, '哲学', '存在与时间', '此在自始至终都处于沉沦状态,芸芸众生'),
       (5, '数学', '代数几何', '仿佛来自虚空'),
       (8, '文学', '浮士德', '与魔鬼交易, 重活一世');
```

实体类

```java
public class Book {
    private Integer id;
    private String type;
    private String name;
    private String description;
}
```

#### 2.7.4 dao层(自动代理)

```java
public interface BookDao {
    @Insert("insert into tbl_book(id, type, name, description) values (null,#{type},#{name},#{description})")
    void save(Book book);

    @Update("update tbl_book set type=#{type},name=#{name},description=#{description} where id=#{id}")
    void update(Book book);

    @Delete("delete from tbl_book where id=#{id}")
    void delete(Integer id);

    @Select("select id, type, name, description from tbl_book where id = #{id}")
    Book getById(Integer id);

    @Select("select id, type, name, description from tbl_book")
    List<Book> getAll();
}
```

#### 2.7.5service层及单元测试

```java
public interface BookService {
    /**
     * 保存
     *
     * @param book
     * @return
     */
    boolean save(Book book);

    /**
     * 修改
     *
     * @param book
     * @return
     */
    boolean update(Book book);

    /**
     * 根据id删除
     *
     * @param id
     * @return
     */
    boolean delete(Integer id);

    /**
     * 按id查询
     *
     * @param id
     * @return
     */
    Book getById(Integer id);

    /**
     * 查询全部
     *
     * @return
     */
    List<Book> getAll();
}
```

实现类

```java
@Service
@Transactional(rollbackFor = Exception.class)
public class BookServiceImpl implements BookService {
    @Autowired
    private BookDao bookDao;
    @Override
    public boolean save(Book book) {
        bookDao.save(book);
        return true;
    }
    @Override
    public boolean update(Book book) {
        bookDao.update(book);
        return true;
    }
    @Override
    public boolean delete(Integer id) {
        bookDao.delete(id);
        return true;
    }
    @Override
    public Book getById(Integer id) {
        return bookDao.getById(id);
    }
    @Override
    public List<Book> getAll() {
        return bookDao.getAll();
    }
}
```

service层接口测试

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes = SpringConfig.class)
public class BookServiceImplTest {
    @Autowired
    private BookService bookService;

    @Test
    public void getById() {
        Book book = bookService.getById(1);
        Assert.assertNotNull(book);
        System.out.println(book);
    }

    @Test
    public void getAll() {
        List<Book> bookList = bookService.getAll();
        Assert.assertNotNull(bookList);
        Assert.assertTrue(!bookList.isEmpty());
        System.out.println("bookList = " + bookList);
    }
}
```



#### 2.7.6controller层及表现层接口测试(idea HttpClient)

```java
@RestController
@RequestMapping("/books")
public class BookController {

    @Autowired
    private BookService bookService;

    @PostMapping
    public boolean save(@RequestBody Book book) {
        return bookService.save(book);
    }

    @PutMapping
    public boolean update(@RequestBody Book book) {
        return bookService.update(book);
    }

    @DeleteMapping("/{id}")
    public boolean delete(@PathVariable Integer id) {
        return bookService.delete(id);
    }

    @GetMapping("/{id}")
    public Book getById(@PathVariable Integer id) {
        return bookService.getById(id);
    }

    @GetMapping
    public List<Book> getAll() {
        return bookService.getAll();
    }
}
```

表现层接口测试

```java
# springmvc_08_ssm
###
GET http://localhost/books

###
GET http://localhost/books/1

###
PUT http://localhost/books
Content-Type: application/json

{
  "id": 1,
  "type": "文学",
  "name": "老人与海",
  "description": "海明威代表作, 一个人可以被消灭,但是不能被打败-修改test"
}

###
POST http://localhost/books
Content-Type: application/json

{
  "id": null,
  "type": "文学",
  "name": "浮士德",
  "description": "与魔鬼交易, 重活一世"
}

###
DELETE http://localhost/books/7
```

#### 2.7.7表现层与前端数据传输协议定义

统一数返回结果数据格式: 错误码code,数据data对象,消息对象msg

![1630654293972](C:\Users\32929\Desktop\cai\backend\ssm\课程笔记\基础框架8笔记\SpringMVC笔记\SpringMVC_day02\assets\1630654293972.png)

```java
public class Result{
	private Object data;
	private Integer code;
	private String msg;
    // 构造方法可以有空参的, 带msg(失败)和不带msg(成功)
}
```

定义统一响应码

```java
package com.xxx.controller;

public class Code {
    public static final Integer SAVE_OK = 20011;
    public static final Integer DELETE_OK = 20021;
    public static final Integer UPDATE_OK = 20031;
    public static final Integer GET_OK = 20041;

    public static final Integer SAVE_ERR = 20010;
    public static final Integer DELETE_ERR = 20020;
    public static final Integer UPDATE_ERR = 20030;
    public static final Integer GET_ERR = 20040;
}		
```

改造controller层返回数据封装

```java
@PostMapping
    public Result save(@RequestBody Book book) {
        boolean isSuccess = bookService.save(book);
        return new Result(isSuccess ? Code.SAVE_OK : Code.SAVE_ERR, isSuccess);
    }

    @PutMapping
    public Result update(@RequestBody Book book) {
        boolean isSuccess = bookService.update(book);
        return new Result(isSuccess ? Code.UPDATE_OK : Code.UPDATE_ERR, isSuccess);
    }

    @DeleteMapping("/{id}")
    public Result delete(@PathVariable Integer id) {
        boolean isSuccess = bookService.delete(id);
        return new Result(isSuccess ? Code.DELETE_OK : Code.DELETE_ERR, isSuccess);
    }

    @GetMapping("/{id}")
    public Result getById(@PathVariable Integer id) {
        Book book = bookService.getById(id);
        Integer code = book != null ? Code.GET_OK : Code.GET_ERR;
        String msg = book != null ? "" : "数据查询失败, 请重试";
        return new Result(code, book, msg);
    }

    @GetMapping
    public Result getAll() {
        List<Book> bookList = bookService.getAll();
        Integer code = bookList != null ? Code.GET_OK : Code.GET_ERR;
        String msg = bookList != null ? "" : "数据查询失败, 请重试";
        return new Result(code, bookList, msg);
    }
```

测试

```java
GET http://localhost/books/1
// 响应结果
{
  "data": {
    "id": 1,
    "type": "文学",
    "name": "老人与海",
    "description": "海明威代表作, 一个人可以被消灭,但是不能被打败-修改test11"
  },
  "code": 20041,
  "msg": ""
}
```

#### 2.7.8异常处理器

#### 2.7.8.1异常的种类及出现异常的原因:

- 框架内部抛出的异常：因使用不合规导致
- 数据层抛出的异常：因外部服务器故障导致（例如：服务器访问超时）
- 业务层抛出的异常：因业务逻辑书写错误导致（例如：遍历业务书写操作，导致索引异常等）
- 表现层抛出的异常：因数据收集、校验等规则导致（例如：不匹配的数据类型间导致异常）
- 工具类抛出的异常：因工具类书写不严谨不够健壮导致（例如：必要释放的连接长期未释放等）

看完上面这些出现异常的位置，你会发现，在我们开发的任何一个位置都有可能出现异常，而且这些异常是不能避免的。所以我们就得将异常进行处理。

1. 各个层级均出现异常，异常处理代码书写在哪一层?

   ==所有的异常均抛出到表现层进行处理==

2. 异常的种类很多，表现层如何将所有的异常都处理到呢?

   ==异常分类==

3. 表现层处理异常，每个方法中单独书写，代码书写量巨大且意义不强，如何解决?

   ==AOP==

#### 2.7.8.2 SpringMVC的统一异常处理

对于上面这些问题及解决方案，SpringMVC已经为我们提供了一套解决方案:

* 异常处理器:

  * 集中的、统一的处理项目中出现的异常

  ```java
  @RestControllerAdvice // 标识当前类为REST风格对应的异常处理器
  public class ProjectExceptionAdvice {
      // 除了自定义的异常处理器，保留对Exception类型的异常处理，用于处理非预期的异常
      @ExceptionHandler(Exception.class)
      public Result doException(Exception ex) {
          System.out.println("catch a ex! " + ex);
          return new Result(666, null,"catch a exception.");
      }
  }
  ```

配置包扫描的时候, 确保SpringMvcConfig能够扫到该类

在程序getById方法中加个异常,调用该方法后结果如下

```java
###
GET http://localhost/books/1
{
  "data": null,
  "code": 666,
  "msg": "catch a exception."
}
```

这样, 就算后端服务出了异常, 也能按照和前端约好的数据格式返回给前端了

**知识点1：@RestControllerAdvice**

| 名称 | @RestControllerAdvice              |
| ---- | ---------------------------------- |
| 类型 | ==类注解==                         |
| 位置 | Rest风格开发的控制器增强类定义上方 |
| 作用 | 为Rest风格开发的控制器类做增强     |

**说明:**此注解自带@ResponseBody注解与@Component注解，具备对应的功能

**知识点2：@ExceptionHandler**

| 名称 | @ExceptionHandler                                            |
| ---- | ------------------------------------------------------------ |
| 类型 | ==方法注解==                                                 |
| 位置 | 专用于异常处理的控制器方法上方                               |
| 作用 | 设置指定异常的处理方案，功能等同于控制器方法，<br/>出现异常后终止原始控制器执行,并转入当前方法执行 |

**说明：**此类方法可以根据处理的异常不同，制作多个方法分别处理对应的异常

2.7.8.2 项目异常处理方案

异常的分类的必要性 如果对每一个异常都进行配置一个异常处理器, 异常太多, 无法面面俱到,也比较繁琐.

如果只使用一个异常的话, 也无法区分出到底是哪个层面出现异常, 定位问题

项目异常分类

- 业务异常
  - 规范的用户行为产生的异常
  - 不规范的用户行为产生的异常
- 系统异常
  - 项目运行过程中可以预计但是无法避免的异常
- 其他异常
  - 编程人员未预期到的异常

项目异常处理方案

- 业务异常(Business Exception)
  - 发送对应消息传递给用户, 提醒规范操作
- 系统异常(System Exception)
  - 发送固定消息传递给用户, 安抚用户
  - 发送特定消息给运维人员, 提醒用户
  - 记录日志
- 其他异常(Exception)
  - 发送固定消息传递给用户, 安抚用户
  - 发送特定消息给运编程人员, 提醒维护(纳入预期范围内)
  - 记录日志

#### 2.7.8.3异常处理实现

代码目录

![image-20240804132452409](C:\Users\32929\Documents\GitHub\zangxin51.github.io\img\md-img\image-20240804132452409.png)

思路: 定义系统异常和业务异常类, 对应业务场景, 把异常抛出去, 然后通过异常处理器在表现层捕捉, 在异常通知对应的异常类型方法进行处理, 获取异常错误码,和错误信息, 最后响应给客户端

1.定义业务异常和系统异常

```java
public class BusinessException extends RuntimeException{
    private Integer code;

    public BusinessException(Integer code, String message) {
        super(message);
        this.code = code;
    }

    public BusinessException(Integer code, String message, Throwable cause) {
        super(message, cause);
        this.code = code;
    }

    public Integer getCode() {
        return code;
    }

    public void setCode(Integer code) {
        this.code = code;
    }
}
```

```java
public class SystemException extends RuntimeException{
    private Integer code;

    public SystemException(Integer code,String message) {
        super(message);
        this.code = code;
    }

    public SystemException(Integer code, String message, Throwable cause) {
        super(message, cause);
        this.code = code;
    }

    public Integer getCode() {
        return code;
    }

    public void setCode(Integer code) {
        this.code = code;
    }
}
```

2.定义异常错误码

```java
public class Code {
    // 异常错误码
    public static final Integer SYSTEM_ERR = 50001;
    public static final Integer SYSTEM_TIMEOUT_ERR = 50002;
    public static final Integer BUSINESS_ERR = 50003;

    public static final Integer SYSTEM_UNKNOW_ERR = 50009;
}
```

3.定义表现层异常通知类异常处理方法

```java
@RestControllerAdvice
public class ProjectExceptionAdvice {
    // 兜底异常,处理其他异常
    @ExceptionHandler(Exception.class)
    public Result doException(Exception ex) {
        // 记录日志,  发送消息给运维, 发送邮件给开发人员, ex对象发送给开发人员
        return new Result(Code.SYSTEM_UNKNOW_ERR, null, "系统繁忙, 请稍后再试!");
    }

    @ExceptionHandler(SystemException.class)
    public Result doSystemException(SystemException ex) {
        return new Result(ex.getCode(), null, ex.getMessage());
    }

    @ExceptionHandler(BusinessException.class)
    public Result doBusinessException(BusinessException ex) {
        return new Result(ex.getCode(), null, ex.getMessage());
    }
}
```

4.使用异常场景

```java
// 根据id获取book
public Book getById(Integer id) {
    // 传入的id值不规范, 抛出业务异常, 让异常处理器捕捉
    if (id < 0) {
        throw new BusinessException(Code.BUSINESS_ERR, "请勿进行非法操作");
    }
    return bookDao.getById(id);
}
```

5.Test

```json
GET http://localhost/books/-1
{
  "data": null,
  "code": 50003,
  "msg": "请勿进行非法操作"
}
```

#### 2.7.8.4前端页面

前端页面的 增 删 改 查

```java
<!DOCTYPE html>
<html>
<head>
    <!-- 页面meta -->
    <meta charset="utf-8">
    <title>SpringMVC案例</title>
    <!-- 引入样式 -->
    <link rel="stylesheet" href="../plugins/elementui/index.css">
    <link rel="stylesheet" href="../plugins/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="../css/style.css">
</head>

<body class="hold-transition">
    <div id="app">
        <div class="content-header">
            <h1>图书管理</h1>
        </div>

        <div class="app-container">
            <div class="box">
                <div class="filter-container">
                    <el-input placeholder="图书名称" v-model="searchBookName" style="width: 200px;"
                              class="filter-item"></el-input>
                    <el-button type="primary" class="butT" @click="getByName()">查询</el-button>
                    <el-button type="primary" class="butT" @click="resetSearch()">重置</el-button>
                    <el-button type="primary" class="butT" @click="openSave()">新建</el-button>
                </div>

                <el-table size="small" current-row-key="id" :data="dataList" stripe highlight-current-row>
                    <el-table-column type="index" align="center" label="序号"></el-table-column>
                    <el-table-column prop="type" label="图书类别" align="center"></el-table-column>
                    <el-table-column prop="name" label="图书名称" align="center"></el-table-column>
                    <el-table-column prop="description" label="描述" align="center"></el-table-column>
                    <el-table-column label="操作" align="center">
                        <template slot-scope="scope">
                            <el-button type="primary" size="mini" @click="openEdit(scope.row.id)">编辑</el-button>
                            <el-button size="mini" type="danger" @click="removeById(scope.row.id)">删除</el-button>
                        </template>
                    </el-table-column>
                </el-table>
                <div class="pagination-container">
                    <el-pagination
                            class="pagiantion"
                            @current-change="handleCurrentChange"
                            :current-page="pagination.currentPage"
                            :page-size="pagination.pageSize"
                            layout="total, prev, pager, next, jumper"
                            :total="pagination.total">
                    </el-pagination>
                </div>
                <!-- 新增标签弹层 -->
                <div class="add-form">
                    <el-dialog title="新增图书" :visible.sync="dialogFormVisible">
                        <el-form ref="dataAddForm" :model="formData" :rules="rules" label-position="right"
                                 label-width="100px">
                            <el-row>
                                <el-col :span="12">
                                    <el-form-item label="图书类别" prop="type">
                                        <el-input v-model="formData.type"/>
                                    </el-form-item>
                                </el-col>
                                <el-col :span="12">
                                    <el-form-item label="图书名称" prop="name">
                                        <el-input v-model="formData.name"/>
                                    </el-form-item>
                                </el-col>
                            </el-row>
                            <el-row>
                                <el-col :span="24">
                                    <el-form-item label="描述">
                                        <el-input v-model="formData.description" type="textarea"></el-input>
                                    </el-form-item>
                                </el-col>
                            </el-row>
                        </el-form>
                        <div slot="footer" class="dialog-footer">
                            <el-button @click="dialogFormVisible = false">取消</el-button>
                            <el-button type="primary" @click="saveBook()">确定</el-button>
                        </div>
                    </el-dialog>
                </div>
                <!-- 编辑标签弹层 -->
                <div class="add-form">
                    <el-dialog title="编辑图书" :visible.sync="dialogFormVisible4Edit">
                        <el-form ref="dataAddForm" :model="formData" :rules="rules" label-position="right"
                                 label-width="100px">
                            <el-row>
                                <el-col :span="12">
                                    <el-form-item label="图书类别" prop="type">
                                        <el-input v-model="formData.type"/>
                                    </el-form-item>
                                </el-col>
                                <el-col :span="12">
                                    <el-form-item label="图书名称" prop="name">
                                        <el-input v-model="formData.name"/>
                                    </el-form-item>
                                </el-col>
                            </el-row>
                            <el-row>
                                <el-col :span="24">
                                    <el-form-item label="描述">
                                        <el-input v-model="formData.description" type="textarea"></el-input>
                                    </el-form-item>
                                </el-col>
                            </el-row>
                        </el-form>
                        <div slot="footer" class="dialog-footer">
                            <el-button @click="dialogFormVisible4Edit = false">取消</el-button>
                            <el-button type="primary" @click="editSaveBook()">确定</el-button>
                        </div>
                    </el-dialog>
                </div>
            </div>
        </div>
    </div>
</body>
<!-- 引入组件库 -->
<script src="../js/vue.js"></script>
<script src="../plugins/elementui/index.js"></script>
<script type="text/javascript" src="../js/jquery.min.js"></script>
<script src="../js/axios-0.18.0.js"></script>
<script>
    var vue = new Vue({
        el: '#app',
        data: {
            searchBookName: '',
            dataList: [],//当前页要展示的分页列表数据
            formData: {},//表单数据
            dialogFormVisible: false,//增加表单是否可见
            dialogFormVisible4Edit: false,//编辑表单是否可见
            pagination: {},//分页模型数据，暂时弃用
        },
        created() {
            this.getById()
        },
        methods: {
            // 重置表单
            resetForm() {
                //清空输入框
                this.formData = {};
            },
            // 弹出添加窗口
            openSave() {
                this.dialogFormVisible = true;
                this.resetForm();
            },
            //添加
            saveBook() {
                axios.post("/books", this.formData).then((res) => {
                    console.log(res)
                    if (res.data.code == 20011) {
                        this.$message.success("添加成功")
                        this.dialogFormVisible = false;
                    } else if (res.data.code != 20011) {
                        this.$message.error(res.data.msg)
                    }
                }).finally(() => {
                    this.getById()
                });
            },
            // 弹出编辑窗口, 然后掉后端接口getById回显数据
            openEdit(bookId) {
                this.dialogFormVisible4Edit = true;
                axios.get("/books/" + bookId).then((res) => {
                    this.formData = res.data.data
                })
            },
            // 编辑保存书籍
            editSaveBook() {
                axios.put("/books", this.formData).then((res) => {
                    if (res.data.code == 20031) {
                        this.dialogFormVisible4Edit = false;
                        this.$message.success("修改成功")
                    } else {
                        this.$message.error(res.data.msg)
                    }
                }).finally(() => {
                    this.getById()
                })
            },
            // 删除
            removeById(bookId) {
                this.$confirm("是否确认删除?", "提示", {
                    type: 'info'
                }).then(() => {
                    axios.delete("/books/" + bookId).then((res) => {
                        if (res.data.code == 20021) {
                            this.$message.success("删除成功")
                            this.getById()
                        } else {
                            this.$message.error("删除失败")
                        }
                    })
                }).catch(() => {
                    this.$message.error("取消删除")
                })
            },
            // getById 或getAll, 根据bookId是否有值
            getById(bookId) {
                console.log('bookId=' + bookId)
                // 如果bookId不为空,就把id传给后端,调用getById,为空时就不传递id,调用getAll
                axios.get("/books/" + (!bookId ? '' : bookId)).then((res) => {
                    if (!bookId) {
                        this.dataList = res.data.data
                    } else {
                        this.dataList = [res.data.data];
                    }
                });
            },
            // 按书名查找
            getByName() {
                if (!this.searchBookName) {
                    return
                } else {
                    axios.get('/books/search/' + this.searchBookName).then((res) => {
                        this.dataList = res.data.data
                    });
                }
            },
            // 重置查询
            resetSearch() {
                this.searchBookName = '';
                this.getById();
            }
        }
    })
</script>
</html>
```

