---


layout:     post
title:      "SSM框架"
subtitle:   "ssm"
date:       2024-08-01 11:58:00
author:     "zangxin"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
---

**SSM**

## 1.spring

用途: 简化javaweb开发

- [ ] **IOC**
- [ ] **AOP**(事务)

官网: spring.io

Spring Framework

Spring Boot

### 1.1spring 架构

![image-20240801091412451](\img\md-img\image-20240801091412451.png)

### 1.2 IOC

**IOC**: inversion of control 控制反转, 使用对象时由自己**new**对象, 转换成, 由**外部**提供对象, 对象创建的控制权限转移到**外部**.

**IOC**容器: spring提供了一个容器, 就是上面的**外部**. IOC容器负责对象的创建, 初始化的工作, 被创建的对象在IOC容器中称为Bean.

**DI**: dependency injection 依赖注入,

- 在容器中建立bean与bean之间的依赖关系, 自动注入bean

**解耦**

- 使用IOC容器管理bean (IOC)
- 在IOC容器中将有依赖关系的bean进行绑定(DI)
- 效果: 使用对象时可以从IOC容器中获取, 并且bean已经绑定对其他bean的依赖关系
- **不用new对象, 依赖自动处理好**

#### 1.2.1 spring quickstart

1. 管理什么? (service与dao)
2. 如何将管理对象告知IOC容器? (配置)
3. 如何获取IOC容器? (接口)
4. 如何从IOC中获取bean? 
5. 如何使用spring? (pom.xml)

##### 1.配置maven坐标

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>5.3.30</version>
</dependency>
```

##### 2.在resources目录下配置applicationContext.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean class="com.xxx.spring.dao.impl.BookDaoImpl" id="bookDao"/>

    <bean class="com.xxx.spring.servcie.impl.BookServiceImpl" id="bookService"></bean>
    
</beans>
```

##### 3.**从IOC容器获取bean测试**

```java
public class APP {
    public static void main(String[] args) {
        // 获取容器
        ApplicationContext context = new 	ClassPathXmlApplicationContext("classpath:*.xml");
        BookDao bookDao = context.getBean("bookDao", BookDao.class);
        bookDao.addBook();

        BookService bookService = (BookService) context.getBean("bookService");
        bookService.addBook();
    }
}
```

##### 4.DI测试

```java
public class BookServiceImpl implements BookService {
    // 不用new对象了,只用声明有这个属性
    private BookDao bookDao;

    @Override
    public void addBook() {
        bookDao.addBook();
        System.out.println("add success [BookServiceImpl]");

    }
	// 必须添加setter方法
    public void setBookDao(BookDao bookDao) {
        this.bookDao = bookDao;
    }
}
```

绑定service和dao的关系

```xml
<bean class="com.xxx.spring.dao.impl.BookDaoImpl" id="bookDao"/>

<!-- 配置service与dao的关系, 绑他两的关系 -->
<bean class="com.xxx.spring.servcie.impl.BookServiceImpl" id="bookService">
    <property name="bookDao" ref="bookDao"></property>
</bean>
```

#### 1.2.2 bean的配置

bean标签的属性

id和name效果相同, ref=name/id和ctx.get(name/id)

property:设置属性,利用setter方法

scop:  决定ctx.get()出来对象是不是同一个

- singleton 单例
- prototype 非单例
- 适合单例的对象: 表现层对象, 业务层,dao层,工具类, 不适合的: 请求对象/属性经常变化



#### 1.2.3bean的实例化

##### **1.无参构造方法**

暴力破解反射,私有构造器也可以造对象 ,但是必须提供无参构造器, 否则会异常:

No default constructor found; nested exception is java.lang.NoSuchMethodException: com.xxx.spring.dao.impl.BookDaoImpl.\<init>()

```java
try {
    BookDao obj = (BookDao) clazz.newInstance();
    obj.addBook();
} catch (Exception e) {}
```

##### 2.静态工厂

```xml
<!--  使用静态工厂实例化bean,class写工厂类  -->
<bean class="com.xxx.spring.factory.BookDaoFactory" id="bookDao" factory-method="getBookDao"/>
```

```java
// 静态工厂
public class BookDaoFactory {
    public static BookDao getBookDao() {
        return new BookDaoImpl();
    }
}
```

##### 3.实例工厂

```xml
<!--  实例工厂  -->
<bean id="instanceFactory" class="com.xxx.spring.factory.BookDaoInstanceFactory"/>
<bean id="bookDao" factory-method="getBookDao" factory-bean="instanceFactory"/>
```

```java
// 实例工厂
public class BookDaoInstanceFactory {
    public  BookDao getBookDao() {
        return new BookDaoImpl();
    }
}
```

4. FactoryBean 实例工厂的简化(配置两个bean简化一个bean)  实现FactoryBean接口

```xml
    <!-- FactoryBean方式 -->
    <bean id="bookDao" class="com.xxx.spring.factory.BookDaoFactoryBean"/>	
```

```java
public class BookDaoFactoryBean implements FactoryBean<BookDao> {
    // 代替原始实例工厂中创建对象的方法
    public BookDao getObject() throws Exception {
        return new BookDaoImpl();
    }

    public Class<?> getObjectType() {
        return BookDao.class;
    }
}
```

1.2.4bean的生命周期

- 初始化容器
  1. 创建对象
  2. 执行构造方法
  3. 执行属性注入(setter)
  4. 执行bean初始化方法 (init-method  InitializingBean接口的afterPropertiesSet方法)
- 使用bean
  1. 执行业务操作
- 关闭/销毁容器
  1. 执行bean销毁方法 (DisposableBean.destroy()方法)

bean的销毁方式两种 (ApplicationContext的子接口ConfigurableApplicationContext下面两个方法)

ctx.close()

// 注册关闭钩子

ctx.registerShutdownHook()

### 1.3 DI 依赖注入

#### 1.setter和构造器注入

- 依赖注入的方式

  1. 普通方法
  2. 构造方法

- 注入的类型

  1. 引用类型
  2. 简单类型(含String)

- **依赖注入方式 (2*2 四种)**

  - 1.setter注入(**用property标签** **setter方法必须**)

    - **简单类型 (value)**

      ```xml
      <property name="databaseUrl" value="jdbc:mysql://localhost:3306/top_news"></property>
      ```

      

    - **引用类型(ref)**

      ```xml
      <property name="bookDao" ref="bookDao"></property>
      ```

  - 构造器注入(必须有全部参数构造器, 可以没有空参构造器)

    - 简单类型(**用constructor-arg标签**)

    - 引用类型


```xml
<!--  形参名要和构造器一致,形参耦合问题  -->
<bean id="userService" class="com.xxx.spring.servcie.impl.UserServiceImpl">
  <constructor-arg name="username" value="root"></constructor-arg>
  <constructor-arg name="userDao" ref="userDao"></constructor-arg>
</bean>

<!--  按类型注入 不靠谱的解决方法 -->
<bean id="userService" class="com.xxx.spring.servcie.impl.UserServiceImpl">
  <constructor-arg type="com.xxx.spring.dao.UserDao" ref="userDao"></constructor-arg>
  <constructor-arg type="java.lang.String" value="root"></constructor-arg>
</bean>

<!--  按参数位置 费力的解决方法 -->
<bean id="userService" class="com.xxx.spring.servcie.impl.UserServiceImpl">
  <constructor-arg index="0" ref="userDao"></constructor-arg>
  <constructor-arg index="1" value="root"></constructor-arg>
</bean>

<bean id="userDao" class="com.xxx.spring.dao.impl.UserDaoImpl"/>
```



#### 2.依赖注入方式选择

1. 强制依赖使用构造器进行, 使用setter有概率不进行注入导致null对象出现
2. 可选依赖使用setter注入进行,灵活性强
3. spring倡导使用构造器,第三方框架内部大多数采用构造器注入进行数据初始化,相对严谨
4. 如果有必要可以二者一起用
5. 根据实际情况, 没有setter方法就只能用构造器
6. 自己开发的模块使用setter注入(简单好用)

#### 3.依赖自动装配 autowire

1. 按类型 (autowire="byType") 

   ioc找到的目标类型应只有一个 

   需要setter方法

   ```xml
   <bean class="com.xxx.spring.servcie.impl.BookServiceImpl" id="bookService" autowire="byType">
   ```

2. 按名称装配: (autowire="byName")  名称指的是setter方法的名字

   ```xml
   <!-- 配置service与dao的关系, 绑他两的关系 -->
   <bean class="com.xxx.spring.servcie.impl.BookServiceImpl" id="bookService" autowire="byName">
   ```

自动装配的优先级低于setter注入和构造器注入, 同时出现自动装配失效

优先选择按类型自动装配, 按名称自动装配不推荐使用,使用名称耦合度提高了

#### 4.集合注入

数组, list, set, map, properties

```java
public class BookDaoImpl implements BookDao {
    private int[] array;

    private List<String> list;
    private Set<String> set;

    private Map<String, String> map;
    private Properties properties;

    // setter 必须
}
```



```xml
<bean id="bookDao" class="com.xxx.dao.impl.BookDaoImpl">
    <property name="array">
        <array>
            <value>100</value>
            <value>300</value>
            <value>500</value>
        </array>
    </property>
    <property name="list">
        <list>
            <value>hello</value>
            <value>world</value>
            <value>bye</value>
        </list>
    </property>
    <property name="set">
        <set>
            <value>喜洋洋</value>
            <value>美洋洋</value>
            <value>懒羊羊</value>
            <value>懒羊羊</value>
        </set>
    </property>
    <property name="map">
        <map>
            <entry key="username" value="zangxin"/>
            <entry key="age" value="11"/>
            <entry key="birthday" value="2000-01-01"/>
        </map>
    </property>
    <property name="properties">
        <props>
            <prop key="country">CHN</prop>
            <prop key="province">SHANGHAI</prop>
            <prop key="city">SHANGHAI</prop>
        </props>
    </property>
</bean>
<!--添加引用类型时,把value改成ref即可-->
```

### 1.4 数据源对象管理

mysql-connector-j 8.0版本可以使用的mysql server version包括5.7 8.0

![img](..\img\md-img\2024-08-01-ssm\684a2033f4849a0c9a804f3e0b4534b8.png)

com.mysql.cj.jdbc.Driver 是 mysql-connector-java 6以及以上中的

mysql配置(jdbc8.0)

```properties
driver-class-name=com.mysql.cj.jdbc.Driver
url=jdbc:mysql://localhost:3306/test?serverTimezone=Asia/Shanghai&useUnicode=true&characterEncoding=utf8&useSSL=false
username=root
password=root
```

#### 1.配置文件管理数据源对象

druid和c3p0数据源对象交给spring管理

```xml
<bean id="druidDataSource" class="com.alibaba.druid.pool.DruidDataSource">
    <property name="driverClassName" value="com.mysql.cj.jdbc.Driver"/>
    <property name="url" value="jdbc:mysql://localhost:3306/top_news"/>
    <property name="username" value="root"></property>
    <property name="password" value="root"></property>
</bean>

<bean id="c3p0DataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
    <property name="driverClass" value="com.mysql.cj.jdbc.Driver"/>
    <property name="jdbcUrl" value="jdbc:mysql://localhost:3306/top_news"/>
    <property name="user" value="root"/>
    <property name="password" value="root"/>
</bean>
```

maven依赖

```xml
<dependency>
    <groupId>com.mysql</groupId>
    <artifactId>mysql-connector-j</artifactId>
    <version>8.0.33</version>
</dependency>
<dependency>
    <groupId>c3p0</groupId>
    <artifactId>c3p0</artifactId>
    <version>0.9.1.2</version>
</dependency>
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid</artifactId>
    <version>1.1.16</version>
</dependency>
```

#### 2.jdbc.properites文件方式

1.在spring配置文件中开始context命名空间

![image-20240801222616215](..\img\md-img\image-20240801222616215.png)

2.利用context命名空间加载jdbc.properties文件

3.使用属性占位符${}读取properties文件中的属性

```xml
<!--system-properties-mode="NEVER" 不使用系统环境变量,windows系统环境有个username他的优先度高于${username},所以要关掉-->
<context:property-placeholder location="classpath*:jdbc.properties" system-properties-mode="NEVER"/>
```

```xml
<context:property-placeholder location="classpath*:jdbc.properties"/>
<bean id="druidDataSource" class="com.alibaba.druid.pool.DruidDataSource">
    <property name="driverClassName" value="$${driver-class-name}"/>
    <property name="url" value="${url}"/>
    <property name="username" value="${username}"></property>
    <property name="password" value="${password}"></property>
</bean>
```

```java
// 获取环境变量
Map<String, String> getenv = System.getenv();
System.out.println("username = " + getenv.get("USERNAME"));
```



```java
// 路径获取配置文件
ApplicationContext ctx = new ClassPathXmlApplicationContext("classpath:*.xml");
// 绝对路径
// ApplicationContext ctx1 = new FileSystemXmlApplicationContext("C:\\Users\\....\\src\\main\\resources\\applicationContext.xml");
// 获取bean的三种方式
ctx.getBean("bookDao");
BookDao bookDao = ctx.getBean("bookDao", BookDao.class);
BookDao bookDao1 = ctx.getBean(BookDao.class);
bookDao1.add();
```

![1629984980781](C:\Users\32929\Documents\GitHub\zangxin51.github.io\img\md-img\2024-08-01-ssm\1629984980781.png)

BeanFactory创建完毕后,所有bean均为延迟加载, ApplicationContext默认为非懒加载

通过bean标签的lazy-init属性可以配置是否懒加载

```xml
<bean id="bookDao" class="dao.impl.BookDaoImpl" lazy-init="true"/>
```

BeanFactory是所有容器的顶层接口

```java
// 使用BeanFactory
Resource resource = new ClassPathResource("applicationContext.xml");
BeanFactory bf = new XmlBeanFactory(resource);
BookDao bookDao = bf.getBean(BookDao.class);
bookDao.add();
```

### 1.5 容器总结

![1629986510487](C:\Users\32929\Documents\GitHub\zangxin51.github.io\img\md-img\2024-08-01-ssm\1629986510487.png)

![1629986848563](C:\Users\32929\Documents\GitHub\zangxin51.github.io\img\md-img\2024-08-01-ssm\1629986848563.png)

### 1.6 注解开发

#### 1.定义bean

1. 使用@Component注解, 等价的注解还有三个(Controller,Service,Repository)
2. 配置包扫描

```java
@Component("bookDao")
public class BookDaoImpl implements BookDao {}
```

```xml
<context:component-scan base-package="com.xxx.dao"/>
```

#### 2.纯注解开发

利用java类替代了ApplicationContext.xml配置文件 @ComponentScan替代了context:component-scan标签

AnnotationConfigApplicationContext获取容器对象

```java
@Configuration
@ComponentScan({"com.xxx", "com.xxx.dao"})
public class SpringConfig {}
```

```java
ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);
BookDao bookDao = ctx.getBean("bookDao", BookDao.class);
bookDao.add();
```

